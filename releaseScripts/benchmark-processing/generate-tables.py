#!/usr/bin/env python2.7
import argparse
import csv 
import re
import os

mUltimateHeader = ['File',
                   'Settings',
                   'Toolchain',
                   'Result',
                   'Overall time',
                   'Overall iterations',
                   'TraceCheckerBenchmark_InterpolantComputationTime',
                   'TraceCheckerBenchmark_Conjuncts in SSA',
                   'TraceCheckerBenchmark_Conjuncts in UnsatCore']

def toPercent(row, a, b):
    part = row[a]
    total = row[b]
    
    if part != None and total != None and part != 'null' and total != 'null':
        totalF = float(total);
        if totalF == 0:
            return 0.0
        return float(part) / float(total) 
    return None

def toInt(row, a):
    value = row[a]
    if value != None and value != 'null':
        return int(value)
    return None 

def timeInNanosToSeconds(row, a):
    value = row[a]
    if value != None and value != 'null':
        return float(value) / 1000000000.0
    return None 

def toFloat(row, a):
    value = row[a]
    if value != None and value != 'null':
        return float(value)
    return None 


mRowFuns = { 'Time' : lambda r : timeInNanosToSeconds(r, 'Overall time'),
            'Iter' : lambda r : toInt(r, 'Overall iterations'),
            'InterpolantTime' : lambda r : timeInNanosToSeconds(r, 'TraceCheckerBenchmark_InterpolantComputationTime'),
            'SizeReduction%':lambda r : toPercent(r, 'TraceCheckerBenchmark_Conjuncts in UnsatCore', 'TraceCheckerBenchmark_Conjuncts in SSA')}

def parseArgs():
    # parse command line arguments
    parser = argparse.ArgumentParser(description='Ultimate Latex table generator')
    parser.add_argument('input', type=str, nargs=1, help='A .csv file generated by an Ultimate test suite')
    parser.add_argument('-o', '--output', dest='output', type=str, nargs='?', help='Path to output directory. If not specified, use current working directory.')
    parser.add_argument('-n', '--table-name', dest='name', help='The name of the table we should produce')
    parser.add_argument('-d', '--with-document', dest='withDoc', action='store_true', help='Should we just print the table or also generate a surrounding document?')

    args = parser.parse_args()
    print 'Arguments:', args
    return args

def getSvcompSubFolder(input):
    return re.search('svcomp/(.*)/', input).group(1)

def getSuffix(prefix, input):
    return re.search('.*' + prefix + '(.*)', input).group(1)

def parseCsvFile(fname):
    csvfile = open(fname, 'rb')
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    return csv.DictReader(csvfile, dialect=dialect)

def applyOnCsvFile(reader, fun, *args):
    acc = None
    for row in reader:
        acc = fun(row, acc, *args)
    return acc

def printFields(row, acc):
    for field in mUltimateHeader:
        print row[field],
    print
    return

def getUniqueSet(fieldname, row, acc):
    if acc == None:
        acc = set()
    acc.add(row[fieldname])
    return acc

def getFolders(row, acc):
    if acc == None:
        acc = {}
    for field in mUltimateHeader:
        input = row['File']
        key = getSvcompSubFolder(input)
        if(not key in acc):
            acc[key] = []
        acc[key].append(input)
    return acc

def getResultCountPerSetting(result, row, acc):
    if acc == None:
        acc = {}
    
    setting = row['Settings']
    resultCounter = 0
    if setting in acc:
       resultCounter = acc[setting]
    
    if row['Result'] in result:
        acc[setting] = resultCounter + 1 
        
    return acc

def getResultInputPerSetting(result, row, acc):
    if acc == None:
        acc = {}
    
    setting = row['Settings']
    resultInput = set()
    if not setting in acc:
       acc[setting] = resultInput
    else:
        resultInput = acc[setting]
    
    if row['Result'] in result:
        resultInput.add(row['File']) 
        
    return acc

def getExclusivePerSetting(rows, results):
    matchingInputs = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    acc = {}
    for key, value in matchingInputs.iteritems():
        exclusive = value
        for okey, ovalue in matchingInputs.iteritems():
            if ovalue == value:
                continue
            exclusive = exclusive.difference(ovalue)
            if len(exclusive) == 0:
                break
        acc[key] = exclusive
    return acc

def getExclusiveCountPerSetting(rows, results):
    return mapValues(lambda x : len(x), getExclusivePerSetting(rows, results))

def getMixedInputs(rows, results):
    matchingInputs = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    shared = set.intersection(*matchingInputs.values())
    exclusive = getExclusivePerSetting(rows, results).values()  
    pure = shared.union(*exclusive)  
    return set.union(*matchingInputs.values()).difference(pure)

def getResultCountPerPortfolio(rows, portfolio, results):
    successCounts = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    goodResults = set()
    for key, value in successCounts.iteritems():
        if(key in portfolio):
            goodResults = goodResults.union(value)
        
    return len(goodResults)

def getCrashedInputs(rows, uniqueSettings):
    acc = {}
    max = 0
    for row in rows:
        file = row['File']
        if file in acc:
           settings = acc[file]
        else:
            settings = set()
            acc[file] = settings
        settings.add(row['Settings'])
        if max < len(settings):
            max = len(settings)
    
    acc = {k:v for k, v in acc.iteritems() if len(v) < max}
    acc = mapValues(lambda v : uniqueSettings.difference(v), acc)
    return acc

def addRowsForCrashedInputs(rows, crashedInputs, uniqueToolchain):
    if len(rows) == 0:
        return
    
    protoRow = rows[0]
    newrows = {}
    for key, value in crashedInputs.iteritems():
        for setting in value:
            newrow = newRow(protoRow)
            newrow['File'] = key
            newrow['Settings'] = setting
            newrow['Result'] = 'ERROR'
            newrow['Toolchain'] = uniqueToolchain
            rows = rows + [newrow] 
    
    return rows

def newRow(row):
    newrow = {}
    for key in row.iterkeys():
        newrow[key] = None
    return newrow

def getPlottable(rows, rowFun, settings):
    acc = {}
    for setting in settings:
        list = []
        acc[setting] = list
        for row in rows:
            if not row['Settings'] in setting:
                continue
            value = rowFun(row)
            if not value == None:
                list.append(value)
        list.sort()
    return acc


def mapKeys(fun, dicti):
    return dict(map(lambda (k, v): (fun(k), v), dicti.iteritems()))

def mapValues(fun, dicti):
    return dict(map(lambda (k, v): (k, fun(v)), dicti.iteritems()))


def writePlots(successrows, uniqueSettings, outputDir):
    for funName, fun in mRowFuns.iteritems():
        plottable = getPlottable(successrows, fun, map(lambda x : (x), uniqueSettings))
        for setting, values in plottable.iteritems():
            f = open(os.path.join(outputDir, funName + '-' + os.path.basename(setting) + '.plot'), 'w')
            print 'Writing', os.path.realpath(f.name)
            i = 0
            for val in values:
                f.write(str(i) + ' ' + str(val) + '\n')
                i = i + 1
                
    return

def main():
    args = parseArgs()
    file = args.input[0]
    
    output = args.output
    if output == None:
        output = os.getcwd()
    
    rows = list(parseCsvFile(file))
    uniqueSettings = applyOnCsvFile(rows, lambda x, y : getUniqueSet('Settings', x, y))
    uniqueToolchains = applyOnCsvFile(rows, lambda x, y : getUniqueSet('Toolchain', x, y))
    
    if len(uniqueToolchains) > 1:
        print 'We only support 1 toolchain per .csv so far, sorry'
        SystemExit(1)
    
    crashed = getCrashedInputs(rows, uniqueSettings)
    rows = addRowsForCrashedInputs(rows, crashed, next(iter(uniqueToolchains)))
    
    
    uniqueFiles = applyOnCsvFile(rows, lambda x, y : getUniqueSet('File', x, y))
    # for s in uniqueSettings:
    #    print s, len(filter(lambda x : x['Settings'] == s, rows))
    
    successResults = ['SAFE', 'UNSAFE']
    solversOnlySettings = filter(lambda x:re.match('.*FB.*|.*BP.*', x), uniqueSettings)
    
    # # one line of unique settings: total success
    success = applyOnCsvFile(rows, lambda x, y : getResultCountPerSetting(successResults, x, y))
    exclusive = getExclusiveCountPerSetting(rows, successResults)
    allPortfolio = getResultCountPerPortfolio(rows, uniqueSettings, successResults)
    otherPortfolio = getResultCountPerPortfolio(rows, solversOnlySettings, successResults)

    mixed = getMixedInputs(rows, successResults)

    remPathD = lambda x : mapKeys(lambda y : getSuffix('settings/automizer/interpolation/', y), x)
    remPathS = lambda x : map(lambda y : getSuffix('settings/automizer/interpolation/', y), x)

    print 'Settings:         ', uniqueSettings
    print 'Total inputs:     ', len(uniqueFiles)
    # print 'Crashed inputs #: ', len(crashed)
    # print 'Crashed inputs:   ', crashed
    print 'Success:          ', remPathD(success)
    print 'Exclusive success:', remPathD(exclusive)
    print 'Portfolio:        ', allPortfolio
    print 'not us Portfolio: ', otherPortfolio
    print 'Mixed:            ', mixed
    print 'Mixed Count:      ', len(mixed)
    
    # # gnuplot and stuff 
    
    successrows = filter(lambda x : x['Result'] in successResults , rows)
    writePlots(successrows, uniqueSettings, output)
    

            
    # applyOnCsvFile(rows, printFields)
    # applyOnCsvFile(rows, lambda x, y : printFields2('haha', x, y))
#     dict = applyOnCsvFile(rows, getFolders)
#     for setting, values in dict.items():
#         print setting
#         for folder in values:
#             print '\t' + folder
    
    return

if __name__ == "__main__":
    main()
