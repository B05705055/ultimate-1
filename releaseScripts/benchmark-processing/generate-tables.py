#!/usr/bin/env python2.7
import argparse
import csv 
import re
import os
import sys
import codecs


mLatexSettingsMappings = {
'DerefFreeMemtrack-32bit-Z3-Sp-Integer.epf' :'\\zzzsp',
'DerefFreeMemtrack-32bit-Z3-IcSp-Integer.epf' :'\\zzzspic',
'DerefFreeMemtrack-32bit-Z3-SpLv-Integer.epf' :'\\zzzsplv',
'DerefFreeMemtrack-32bit-SMTInterpol-TreeInterpolation-Integer.epf' :'\\smtinterpolip',
'DerefFreeMemtrack-32bit-Z3-NestedInterpolation-Integer.epf' :'\\zzzip',
'DerefFreeMemtrack-32bit-Princess-TreeInterpolation-Integer.epf' :'\\princessip',
'DerefFreeMemtrack-32bit-Z3-FPandBP-Integer.epf' :'FP+BP',
'DerefFreeMemtrack-32bit-Z3-BP-Integer.epf' :'\\zzzspiclv BP',
'DerefFreeMemtrack-32bit-Z3-IcSpLv-Integer.epf' : '\\zzzspiclv',
'Reach-32bit-Z3-BP-Bitvector.epf':'\\zzzspiclv BP',
'Reach-32bit-Z3-FPandBP-Bitvector.epf':'FP+BP',
'Reach-32bit-Z3-NestedInterpolation-Bitvector.epf':'\\zzzip',
'Reach-32bit-Z3-FP-Bitvector.epf':'\\zzzspiclv FP',
'Reach-32bit-Princess-TreeInterpolation.epf':'\\princessip',
'Reach-32bit-Z3-FP.epf':'\\zzzspiclv FP',
'Reach-32bit-SMTInterpol-TreeInterpolation.epf':'\\smtinterpolip',
'Reach-32bit-Z3-BP.epf':'\\zzzspiclv BP',
'Reach-32bit-Z3-NestedInterpolation.epf':'\\zzzip',
}

mLatexColors = ['Apricot', 'Aquamarine', 'Bittersweet', 'Black', 'Blue', 'BlueGreen', 'BlueViolet',
                'BrickRed', 'Brown', 'BurntOrange', 'CadetBlue', 'CarnationPink', 'Cerulean', 'CornflowerBlue',
                'Cyan', 'Dandelion', 'DarkOrchid', 'Emerald', 'ForestGreen', 'Fuchsia', 'Goldenrod', 'Gray',
                'Green', 'GreenYellow', 'JungleGreen', 'Lavender', 'LimeGreen', 'Magenta', 'Mahogany', 'Maroon',
                'Melon', 'MidnightBlue', 'Mulberry', 'NavyBlue', 'OliveGreen', 'Orange', 'OrangeRed', 'Orchid',
                'Peach', 'Periwinkle', 'PineGreen', 'Plum', 'ProcessBlue', 'Purple', 'RawSienna', 'Red',
                'RedOrange', 'RedViolet', 'Rhodamine', 'RoyalBlue', 'RoyalPurple', 'RubineRed', 'Salmon',
                'SeaGreen', 'Sepia', 'SkyBlue', 'SpringGreen', 'Tan', 'TealBlue', 'Thistle', 'Turquoise',
                'Violet', 'VioletRed', 'White', 'WildStrawberry', 'Yellow', 'YellowGreen', 'YellowOrange' ]

mUltimateHeader = ['File',
                   'Settings',
                   'Toolchain',
                   'Result',
                   'Overall time',
                   'Overall iterations',
                   'TraceCheckerBenchmark_InterpolantComputationTime',
                   'TraceCheckerBenchmark_Conjuncts in SSA',
                   'TraceCheckerBenchmark_Conjuncts in UnsatCore']

def toPercent(row, a, b):
    part = row[a]
    total = row[b]
    
    if part != None and total != None and part != 'null' and total != 'null':
        totalF = float(total);
        if totalF == 0:
            return 0.0
        return float(part) / float(total) 
    return None

def toInt(row, a):
    value = row[a]
    if value != None and value != 'null':
        return int(value)
    return None 

def timeInNanosToSeconds(row, a):
    value = row[a]
    if value != None and value != 'null':
        return float(value) / 1000000000.0
    return None 

def toFloat(row, a):
    value = row[a]
    if value != None and value != 'null':
        return float(value)
    return None 


mRowFuns = { 'Time' : lambda r : timeInNanosToSeconds(r, 'Overall time'),
            'Iter' : lambda r : toInt(r, 'Overall iterations'),
            'InterpolantTime' : lambda r : timeInNanosToSeconds(r, 'TraceCheckerBenchmark_InterpolantComputationTime'),
            'SizeReduction':lambda r : toPercent(r, 'TraceCheckerBenchmark_Conjuncts in UnsatCore', 'TraceCheckerBenchmark_Conjuncts in SSA')}

def parseArgs():
    # parse command line arguments
    parser = argparse.ArgumentParser(description='Ultimate Latex table generator')
    parser.add_argument('input', type=str, nargs=1, help='A .csv file generated by an Ultimate test suite')
    parser.add_argument('-o', '--output', dest='output', type=str, nargs='?', help='Path to output directory. If not specified, use current working directory.')
    parser.add_argument('-n', '--table-name', dest='name', help='The name of the table we should produce')
    parser.add_argument('-d', '--with-document', dest='withDoc', action='store_true', help='Should we just print the table or also generate a surrounding document?')

    args = parser.parse_args()
    print 'Arguments:', args
    return args

def getSvcompSubFolder(input):
    return re.search('svcomp/(.*)/', input).group(1)

def getSuffix(prefix, input):
    return re.search('.*' + prefix + '(.*)', input).group(1)

def parseCsvFile(fname):
    csvfile = open(fname, 'rb')
    dialect = csv.Sniffer().sniff(csvfile.read(1024))
    csvfile.seek(0)
    return csv.DictReader(csvfile, dialect=dialect)

def applyOnCsvFile(reader, fun, *args):
    acc = None
    for row in reader:
        acc = fun(row, acc, *args)
    return acc

def printFields(row, acc):
    for field in mUltimateHeader:
        print row[field],
    print
    return

def getUniqueSet(fieldname, row, acc):
    if acc == None:
        acc = set()
    acc.add(row[fieldname])
    return acc

def getFolders(row, acc):
    if acc == None:
        acc = {}
    for field in mUltimateHeader:
        input = row['File']
        key = getSvcompSubFolder(input)
        if(not key in acc):
            acc[key] = []
        acc[key].append(input)
    return acc

def getResultCountPerSetting(result, row, acc):
    if acc == None:
        acc = {}
    
    setting = row['Settings']
    resultCounter = 0
    if setting in acc:
       resultCounter = acc[setting]
    
    if row['Result'] in result:
        acc[setting] = resultCounter + 1 
        
    return acc

def getResultInputPerSetting(result, row, acc):
    if acc == None:
        acc = {}
    
    setting = row['Settings']
    resultInput = set()
    if not setting in acc:
       acc[setting] = resultInput
    else:
        resultInput = acc[setting]
    
    if row['Result'] in result:
        resultInput.add(row['File']) 
        
    return acc

def getExclusivePerSetting(rows, results):
    matchingInputs = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    acc = {}
    for key, value in matchingInputs.iteritems():
        exclusive = value
        for okey, ovalue in matchingInputs.iteritems():
            if ovalue == value:
                continue
            exclusive = exclusive.difference(ovalue)
            if len(exclusive) == 0:
                break
        acc[key] = exclusive
    return acc

def getExclusiveCountPerSetting(rows, results):
    return mapValues(lambda x : len(x), getExclusivePerSetting(rows, results))

def getMixedInputs(rows, results):
    matchingInputs = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    shared = set.intersection(*matchingInputs.values())
    exclusive = getExclusivePerSetting(rows, results).values()  
    pure = shared.union(*exclusive)  
    return set.union(*matchingInputs.values()).difference(pure)

def getResultCountPerPortfolio(rows, portfolio, results):
    successCounts = applyOnCsvFile(rows, lambda x, y : getResultInputPerSetting(results, x, y))
    goodResults = set()
    for key, value in successCounts.iteritems():
        if(key in portfolio):
            goodResults = goodResults.union(value)
        
    return len(goodResults)

def getCrashedInputs(rows, uniqueSettings):
    acc = {}
    max = 0
    for row in rows:
        file = row['File']
        if file in acc:
           settings = acc[file]
        else:
            settings = set()
            acc[file] = settings
        settings.add(row['Settings'])
        if max < len(settings):
            max = len(settings)
    
    acc = {k:v for k, v in acc.iteritems() if len(v) < max}
    acc = mapValues(lambda v : uniqueSettings.difference(v), acc)
    return acc

def addRowsForCrashedInputs(rows, crashedInputs, uniqueToolchain):
    if len(rows) == 0:
        return
    
    protoRow = rows[0]
    newrows = {}
    for key, value in crashedInputs.iteritems():
        for setting in value:
            newrow = newRow(protoRow)
            newrow['File'] = key
            newrow['Settings'] = setting
            newrow['Result'] = 'ERROR'
            newrow['Toolchain'] = uniqueToolchain
            rows = rows + [newrow] 
    
    return rows

def newRow(row):
    newrow = {}
    for key in row.iterkeys():
        newrow[key] = None
    return newrow

def getPlottable(rows, rowFun, settings):
    acc = {}
    for setting in settings:
        list = []
        acc[setting] = list
        for row in rows:
            if not row['Settings'] in setting:
                continue
            value = rowFun(row)
            if not value == None:
                list.append(value)
        list.sort()
    return acc


def mapKeys(fun, dicti):
    return dict(map(lambda (k, v): (fun(k), v), dicti.iteritems()))

def mapValues(fun, dicti):
    return dict(map(lambda (k, v): (k, fun(v)), dicti.iteritems()))

def writeLatexFigure(filename, xlabel, ylabel, plotnames, plotfiles, caption):
    
    if len(plotnames) > len(mLatexColors):
        sys.stderr.write('Warning: There are not enough colors, so I will drop some plot lines (but who plots more than 63 plots anyways?') 
    
    plots = zip(mLatexColors, plotfiles)

    f = codecs.open(filename, 'a', 'utf-8')
    f.write('\\begin{figure}\n')
    f.write('\\begin{tikzpicture}\n')
    f.write('\\begin{axis}[%\n')
    f.write('xmin=0, ymin=0,%\n')
    f.write('xlabel={' + xlabel + '},%\n')
    f.write('ylabel={' + ylabel + '},grid=both,axis lines=left,%\n')
    f.write('legend style={at={(0.1,0.9)},anchor=north west,legend cell align=left},%\n')
    f.write('legend entries={')
    for name in plotnames:
        if name in mLatexSettingsMappings:
            f.write(mLatexSettingsMappings[name] + ',',)
        else:
            f.write(name + ',',)
    f.write('},%\n')
    f.write(']\n')
    
    for color, plotfile in plots:
        f.write('\\addplot+[' + color + '!80!black,no marks,opacity=1] table {plots/' + plotfile + '};\n')
    f.write('\\end{axis}\n')
    f.write('\\end{tikzpicture}\n')
    f.write('\\caption{' + caption + '}\n')
    f.write('\\end{figure}\n\n')
    f.close()
    return

def writePlots(successrows, uniqueSettings, outputDir, name):
    plotsfile = os.path.join(outputDir, 'plots.tex')
    if os.path.isfile(plotsfile):
        os.remove(plotsfile)

    for funName, fun in mRowFuns.iteritems():
        plottable = getPlottable(successrows, fun, map(lambda x : (x), uniqueSettings))
        plotfiles = []
        plotnames = []
        for setting, values in plottable.iteritems():
            friendlySetting = os.path.basename(setting)
            filename = funName + '-' + friendlySetting + '.plot'
            f = codecs.open(os.path.join(outputDir, filename), 'w', 'utf-8')
            i = 0
            for val in values:
                f.write(str(i) + ' ' + str(val) + '\n')
                i = i + 1
            f.close()
            if os.stat(f.name).st_size == 0:
                os.remove(f.name)
            else:
                plotfiles.append(filename)
                plotnames.append(friendlySetting)
        if name != '':
            funName = name + ' ' + funName
        writeLatexFigure(plotsfile, 'x', 'y', plotnames, plotfiles, funName)
                
    return

def getArgs():
    args = parseArgs()
    file = args.input[0]
    
    if not os.path.isfile(file):
        print file, 'does not exist'
        sys.exit(1)
        return
    
    output = args.output
    if output == None:
        output = os.getcwd()
    
    name = args.name
    if name == None:
        name = ''
        
    return file, output, name              

def main():
    file, output, name = getArgs()
    
    rows = list(parseCsvFile(file))
    uniqueSettings = applyOnCsvFile(rows, lambda x, y : getUniqueSet('Settings', x, y))
    uniqueToolchains = applyOnCsvFile(rows, lambda x, y : getUniqueSet('Toolchain', x, y))
    
    if len(uniqueToolchains) > 1:
        print 'We only support 1 toolchain per .csv so far, sorry'
        sys.exit(1)
        return
    
    crashed = getCrashedInputs(rows, uniqueSettings)
    rows = addRowsForCrashedInputs(rows, crashed, next(iter(uniqueToolchains)))
    
    
    uniqueFiles = applyOnCsvFile(rows, lambda x, y : getUniqueSet('File', x, y))
    # for s in uniqueSettings:
    #    print s, len(filter(lambda x : x['Settings'] == s, rows))
    
    successResults = ['SAFE', 'UNSAFE']
    solversOnlySettings = filter(lambda x:re.match('.*FB.*|.*BP.*', x), uniqueSettings)
    
    # # one line of unique settings: total success
    success = applyOnCsvFile(rows, lambda x, y : getResultCountPerSetting(successResults, x, y))
    exclusive = getExclusiveCountPerSetting(rows, successResults)
    allPortfolio = getResultCountPerPortfolio(rows, uniqueSettings, successResults)
    otherPortfolio = getResultCountPerPortfolio(rows, solversOnlySettings, successResults)

    mixed = getMixedInputs(rows, successResults)

    remPathD = lambda x : mapKeys(lambda y : getSuffix('settings/automizer/interpolation/', y), x)
    remPathS = lambda x : map(lambda y : getSuffix('settings/automizer/interpolation/', y), x)

    print 'Settings:         ', remPathS(uniqueSettings)
    print 'Total inputs:     ', len(uniqueFiles)
    # print 'Crashed inputs #: ', len(crashed)
    # print 'Crashed inputs:   ', crashed
    print 'Success:          ', remPathD(success)
    print 'Exclusive success:', remPathD(exclusive)
    print 'Portfolio:        ', allPortfolio
    print 'not us Portfolio: ', otherPortfolio
    print 'Mixed:            ', mixed
    print 'Mixed Count:      ', len(mixed)
    print 
    
    # # gnuplot and stuff 
    successrows = filter(lambda x : x['Result'] in successResults , rows)
    writePlots(successrows, uniqueSettings, output, name)
            
    # applyOnCsvFile(rows, printFields)
    # applyOnCsvFile(rows, lambda x, y : printFields2('haha', x, y))
#     dict = applyOnCsvFile(rows, getFolders)
#     for setting, values in dict.items():
#         print setting
#         for folder in values:
#             print '\t' + folder
    
    return

if __name__ == "__main__":
    main()
