#!/bin/bash 
# small script to scan through a set of ultimate logs generated by Ultimate.py and extract an overview 

count=0
valid=0
overapprox=0
overapprox_but_bit_success=0

declare -A exceptions
declare -A timeouts
declare -A safe
declare -A unsafe

known_exceptions=( 
"we do not support pthread"
"UnsupportedSyntaxResult"
"TypeErrorResult"
"SyntaxErrorResult"
"Unable to prove that all allocated memory was freed"
"overapproximation of large string literal"
"TerminationAnalysisResult: Unable to decide termination"
"An exception occured during the execution of Ultimate: The toolchain threw an exception"
)

known_timeouts=(
"Cannot interrupt operation gracefully because timeout expired. Forcing shutdown"
"Toolchain execution was canceled (user or tool) before executing"
)

known_safe=(
"AllSpecificationsHoldResult"
"TerminationAnalysisResult: Termination proven"
)

known_unsafe=(
"CounterExampleResult"
"NonterminatingLassoResult"
)

log_separator_line="Retrying with bit-precise analysis"

# get all before PATTERN
# sed '/PATTERN/q' FILE

exec 3< <(find "$1" -type f -iname '*.log')

while read -u 3 line
do 
    count=$((count+1))
    bit_precise=0
    grep -q "$log_separator_line" "$line"
    if [ $? -eq 0 ]; then 
        bit_precise=1
        overapprox=$((overapprox+1))
        content=`sed -e "1,/### Bit-precise run ###/d" "$line"`
    else
        content=`sed -e "1,/--- Real Ultimate output ---/d" "$line"`
    fi 
    
    length=${#content}
    if [[ "$length" == "0" ]]; then 
	    if grep -q 'No suitable settings file found' "$line"; then
			exceptions["No suitable settings file found"]=$((exceptions["No suitable settings file found"]+1))
			continue 
		fi
	
        timeouts["Unexpected end"]=$((timeouts["Unexpected end"]+1))
        continue     
    fi 
    
    length=$((length-4))
    if [[ "${content:$length:4}" == "...." ]]; then
        timeouts["Unexpected end"]=$((timeouts["Unexpected end"]+1))
        continue 
    fi

    if echo "$content" | grep -q 'ExceptionOrErrorResult'; then
        exc=`echo "$content" | grep -A1 'ExceptionOrErrorResult' | grep -v 'ExceptionOrErrorResult'`
        if [ ! -n "$exc" ]; then 
            exc=`echo "$content" | grep 'ExceptionOrErrorResult'`
        fi
        exc=`echo "$exc" | sed 's/\\$//g'`
        exceptions["$exc"]=$((exceptions["$exc"]+1))
        continue 
    fi
    for i in "${known_exceptions[@]}"; do 
        if echo "$content" | grep -q "$i"; then
            exceptions["$i"]=$((exceptions["$i"]+1))
            continue 2
        fi
    done

    if echo "$content" | grep -qP 'Timeout.*Result'; then
        exc=`echo "$content" | grep -A1 -P 'Timeout.*Result' | grep -vP 'Timeout.*Result'`
        timeouts["$exc"]=$((timeouts["$exc"]+1))
        continue 
    fi
    for i in "${known_timeouts[@]}"; do 
        if echo "$content" | grep -q "$i"; then
            timeouts["$i"]=$((timeouts["$i"]+1))
            continue 2
        fi
    done

    for i in "${known_unsafe[@]}"; do 
        if echo "$content" | grep -q "$i"; then
            unsafe["$i"]=$((unsafe["$i"]+1))
            valid=$((valid+1))
            [ $bit_precise == 1 ] && ((overapprox_but_bit_success++))
            continue 2
        fi
    done
   
    for i in "${known_safe[@]}"; do 
        if echo "$content" | grep -q "$i"; then
            safe["$i"]=$((safe["$i"]+1))
            valid=$((valid+1))
            [ $bit_precise == 1 ] && ((overapprox_but_bit_success++))
            continue 2
        fi
    done
   
    echo "$line contains unhandled result"
    continue
    # here so we dont need to use reset in console 
    #exit 
done

echo "$valid of $count valid ($overapprox tried bit-precise analysis, $overapprox_but_bit_success succeeded)"

tot=0
for i in ${safe[@]}; do
  let tot+=$i
done
echo "$tot safe"

tot=0
for i in ${unsafe[@]}; do
  let tot+=$i
done
echo "$tot unsafe"



tot=0
for i in ${exceptions[@]}; do
  let tot+=$i
done

echo ""
echo "Exceptions ($tot)"
for ex in "${!exceptions[@]}"; do 
    echo "${exceptions[$ex]} : $ex"; 
done

tot=0
for i in ${timeouts[@]}; do
  let tot+=$i
done

echo ""
echo "Timeouts ($tot)"
for ex in "${!timeouts[@]}"; do 
    echo "${timeouts[$ex]} : $ex"; 
done




