/* This file was generated by SableCC (http://www.sablecc.org/). */

package local.TestGrammar.analysis;

import java.util.*;
import local.TestGrammar.node.*;

public class ReversedDepthFirstAdapter extends AnalysisAdapter
{
    public void inStart(Start node)
    {
        defaultIn(node);
    }

    public void outStart(Start node)
    {
        defaultOut(node);
    }

    public void defaultIn(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    public void defaultOut(@SuppressWarnings("unused") Node node)
    {
        // Do nothing
    }

    @Override
    public void caseStart(Start node)
    {
        inStart(node);
        node.getEOF().apply(this);
        node.getPTestFile().apply(this);
        outStart(node);
    }

    public void inATestFile(ATestFile node)
    {
        defaultIn(node);
    }

    public void outATestFile(ATestFile node)
    {
        defaultOut(node);
    }

    @Override
    public void caseATestFile(ATestFile node)
    {
        inATestFile(node);
        {
            List<PAutomatonDefinition> copy = new ArrayList<PAutomatonDefinition>(node.getAutomatonDefinition());
            Collections.reverse(copy);
            for(PAutomatonDefinition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PTestCase> copy = new ArrayList<PTestCase>(node.getTestCase());
            Collections.reverse(copy);
            for(PTestCase e : copy)
            {
                e.apply(this);
            }
        }
        outATestFile(node);
    }

    public void inANestedWordTestCase(ANestedWordTestCase node)
    {
        defaultIn(node);
    }

    public void outANestedWordTestCase(ANestedWordTestCase node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANestedWordTestCase(ANestedWordTestCase node)
    {
        inANestedWordTestCase(node);
        if(node.getNestedWord() != null)
        {
            node.getNestedWord().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getTestOperation() != null)
        {
            node.getTestOperation().apply(this);
        }
        outANestedWordTestCase(node);
    }

    public void inANestedLassoWordTestCase(ANestedLassoWordTestCase node)
    {
        defaultIn(node);
    }

    public void outANestedLassoWordTestCase(ANestedLassoWordTestCase node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANestedLassoWordTestCase(ANestedLassoWordTestCase node)
    {
        inANestedLassoWordTestCase(node);
        if(node.getLoop() != null)
        {
            node.getLoop().apply(this);
        }
        if(node.getStem() != null)
        {
            node.getStem().apply(this);
        }
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getTestOperation() != null)
        {
            node.getTestOperation().apply(this);
        }
        outANestedLassoWordTestCase(node);
    }

    public void inANoWordTestCase(ANoWordTestCase node)
    {
        defaultIn(node);
    }

    public void outANoWordTestCase(ANoWordTestCase node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANoWordTestCase(ANoWordTestCase node)
    {
        inANoWordTestCase(node);
        if(node.getExpression() != null)
        {
            node.getExpression().apply(this);
        }
        if(node.getTestOperation() != null)
        {
            node.getTestOperation().apply(this);
        }
        outANoWordTestCase(node);
    }

    public void inAOperationExpression(AOperationExpression node)
    {
        defaultIn(node);
    }

    public void outAOperationExpression(AOperationExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAOperationExpression(AOperationExpression node)
    {
        inAOperationExpression(node);
        {
            List<PExpression> copy = new ArrayList<PExpression>(node.getExpressions());
            Collections.reverse(copy);
            for(PExpression e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getOperation() != null)
        {
            node.getOperation().apply(this);
        }
        outAOperationExpression(node);
    }

    public void inAAutomatonNameExpression(AAutomatonNameExpression node)
    {
        defaultIn(node);
    }

    public void outAAutomatonNameExpression(AAutomatonNameExpression node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAAutomatonNameExpression(AAutomatonNameExpression node)
    {
        inAAutomatonNameExpression(node);
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outAAutomatonNameExpression(node);
    }

    public void inACallTaggedSymbol(ACallTaggedSymbol node)
    {
        defaultIn(node);
    }

    public void outACallTaggedSymbol(ACallTaggedSymbol node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACallTaggedSymbol(ACallTaggedSymbol node)
    {
        inACallTaggedSymbol(node);
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        outACallTaggedSymbol(node);
    }

    public void inAInternalTaggedSymbol(AInternalTaggedSymbol node)
    {
        defaultIn(node);
    }

    public void outAInternalTaggedSymbol(AInternalTaggedSymbol node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInternalTaggedSymbol(AInternalTaggedSymbol node)
    {
        inAInternalTaggedSymbol(node);
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        outAInternalTaggedSymbol(node);
    }

    public void inAReturnTaggedSymbol(AReturnTaggedSymbol node)
    {
        defaultIn(node);
    }

    public void outAReturnTaggedSymbol(AReturnTaggedSymbol node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReturnTaggedSymbol(AReturnTaggedSymbol node)
    {
        inAReturnTaggedSymbol(node);
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        outAReturnTaggedSymbol(node);
    }

    public void inANestedWord(ANestedWord node)
    {
        defaultIn(node);
    }

    public void outANestedWord(ANestedWord node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANestedWord(ANestedWord node)
    {
        inANestedWord(node);
        {
            List<PTaggedSymbol> copy = new ArrayList<PTaggedSymbol>(node.getNestedWord());
            Collections.reverse(copy);
            for(PTaggedSymbol e : copy)
            {
                e.apply(this);
            }
        }
        outANestedWord(node);
    }

    public void inACallTransition(ACallTransition node)
    {
        defaultIn(node);
    }

    public void outACallTransition(ACallTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseACallTransition(ACallTransition node)
    {
        inACallTransition(node);
        if(node.getSuccessor() != null)
        {
            node.getSuccessor().apply(this);
        }
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        if(node.getPredecessor() != null)
        {
            node.getPredecessor().apply(this);
        }
        outACallTransition(node);
    }

    public void inAInternalTransition(AInternalTransition node)
    {
        defaultIn(node);
    }

    public void outAInternalTransition(AInternalTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAInternalTransition(AInternalTransition node)
    {
        inAInternalTransition(node);
        if(node.getSuccessor() != null)
        {
            node.getSuccessor().apply(this);
        }
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        if(node.getPredecessor() != null)
        {
            node.getPredecessor().apply(this);
        }
        outAInternalTransition(node);
    }

    public void inAReturnTransition(AReturnTransition node)
    {
        defaultIn(node);
    }

    public void outAReturnTransition(AReturnTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAReturnTransition(AReturnTransition node)
    {
        inAReturnTransition(node);
        if(node.getSuccessor() != null)
        {
            node.getSuccessor().apply(this);
        }
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        if(node.getLinearPredecessor() != null)
        {
            node.getLinearPredecessor().apply(this);
        }
        if(node.getPredecessor() != null)
        {
            node.getPredecessor().apply(this);
        }
        outAReturnTransition(node);
    }

    public void inANetTransition(ANetTransition node)
    {
        defaultIn(node);
    }

    public void outANetTransition(ANetTransition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANetTransition(ANetTransition node)
    {
        inANetTransition(node);
        {
            List<TId> copy = new ArrayList<TId>(node.getSuccessors());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getSymbol() != null)
        {
            node.getSymbol().apply(this);
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getPredecessors());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        outANetTransition(node);
    }

    public void inAMarking(AMarking node)
    {
        defaultIn(node);
    }

    public void outAMarking(AMarking node)
    {
        defaultOut(node);
    }

    @Override
    public void caseAMarking(AMarking node)
    {
        inAMarking(node);
        {
            List<TId> copy = new ArrayList<TId>(node.getPlaces());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        outAMarking(node);
    }

    public void inANwaAutomatonDefinition(ANwaAutomatonDefinition node)
    {
        defaultIn(node);
    }

    public void outANwaAutomatonDefinition(ANwaAutomatonDefinition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANwaAutomatonDefinition(ANwaAutomatonDefinition node)
    {
        inANwaAutomatonDefinition(node);
        {
            List<PReturnTransition> copy = new ArrayList<PReturnTransition>(node.getReturnTransitions());
            Collections.reverse(copy);
            for(PReturnTransition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PInternalTransition> copy = new ArrayList<PInternalTransition>(node.getInternalTransitions());
            Collections.reverse(copy);
            for(PInternalTransition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<PCallTransition> copy = new ArrayList<PCallTransition>(node.getCallTransitions());
            Collections.reverse(copy);
            for(PCallTransition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getFinalStates());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getInitialStates());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getStates());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getReturnAlphabet());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getInternalAlphabet());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getCallAlphabet());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANwaAutomatonDefinition(node);
    }

    public void inANetjanAutomatonDefinition(ANetjanAutomatonDefinition node)
    {
        defaultIn(node);
    }

    public void outANetjanAutomatonDefinition(ANetjanAutomatonDefinition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANetjanAutomatonDefinition(ANetjanAutomatonDefinition node)
    {
        inANetjanAutomatonDefinition(node);
        {
            List<PMarking> copy = new ArrayList<PMarking>(node.getAcceptingMarkings());
            Collections.reverse(copy);
            for(PMarking e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getInitialMarking() != null)
        {
            node.getInitialMarking().apply(this);
        }
        {
            List<PNetTransition> copy = new ArrayList<PNetTransition>(node.getTransitions());
            Collections.reverse(copy);
            for(PNetTransition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getPlaces());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getAlphabet());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANetjanAutomatonDefinition(node);
    }

    public void inANetjulianAutomatonDefinition(ANetjulianAutomatonDefinition node)
    {
        defaultIn(node);
    }

    public void outANetjulianAutomatonDefinition(ANetjulianAutomatonDefinition node)
    {
        defaultOut(node);
    }

    @Override
    public void caseANetjulianAutomatonDefinition(ANetjulianAutomatonDefinition node)
    {
        inANetjulianAutomatonDefinition(node);
        {
            List<TId> copy = new ArrayList<TId>(node.getAcceptingPlaces());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getInitialMarking() != null)
        {
            node.getInitialMarking().apply(this);
        }
        {
            List<PNetTransition> copy = new ArrayList<PNetTransition>(node.getTransitions());
            Collections.reverse(copy);
            for(PNetTransition e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getPlaces());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        {
            List<TId> copy = new ArrayList<TId>(node.getAlphabet());
            Collections.reverse(copy);
            for(TId e : copy)
            {
                e.apply(this);
            }
        }
        if(node.getName() != null)
        {
            node.getName().apply(this);
        }
        outANetjulianAutomatonDefinition(node);
    }
}
