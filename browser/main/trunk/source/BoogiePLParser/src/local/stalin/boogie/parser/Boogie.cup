/* CUP specification for BoogiePL */

package local.stalin.boogie.parser;
import java.util.Collections;
import java.util.List;
import java.util.LinkedList;
import java_cup.runtime.Symbol;
import local.stalin.boogie.parser.BoogieSymbolFactory.BoogieSymbol;
import local.stalin.model.boogie.ast.*;

parser Parser;
option symbols = LexerSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;
	public void setFileName(String filename) {
		this.filename = filename;
	}
	
	public void syntax_error(Symbol sym) {
	    String position;
	    if (sym instanceof BoogieSymbol) {
			BoogieSymbol bsym = (BoogieSymbol) sym;
			position = filename+":"+bsym.getLocation();
		} else  {
			position = filename + ":EOF";
		}
		BoogieParser.s_Logger.error(position + ": syntax error");
	}
:}

action code {:
	public BitvecLiteral parseBitvec(String bitvec) {
		int bvPos = bitvec.indexOf("bv");
		int length = Integer.parseInt(bitvec.substring(bvPos+2));
		return new BitvecLiteral(bitvec.substring(0, bvPos), length);
	}
:}

/*init with {: getScanner().init(); :} */
scan with {: return getScanner().next_token(); :}


/* Keywords */
terminal TYPE, CONST, FUNCTION, AXIOM, VAR, PROCEDURE, IMPLEMENTATION;
terminal FINITE, UNIQUE, COMPLETE, RETURNS, WHERE;
terminal FREE, REQUIRES, ENSURES, MODIFIES, INVARIANT;
terminal OLD;
terminal FORALL, EXISTS;
terminal BOOL, INT, REAL;
terminal FALSE, TRUE;
terminal ASSUME, ASSERT, HAVOC, CALL, IF, THEN, ELSE, WHILE, BREAK, RETURN, GOTO;
/* Other Symbols */
terminal COMMA, COLON, SEMI, COLONEQUALS, EQUALS;
terminal LPAR, RPAR, LBKT, RBKT, LBRC, RBRC, LANG, RANG;
terminal LESS, GREATER, LTEQ, GTEQ, NEQ, EQ, PARTORDER;
terminal PLUS, MINUS;
terminal TIMES, DIVIDE, MOD;
terminal QSEP, NOT, OR, AND, IMPLIES, IFF, EXPLIES;
terminal CONCAT;
/* Numbers, Ids and Strings */
terminal String BVTYPE;
terminal String NUMBER;
terminal String REALNUMBER;
terminal String BITVECTOR;
terminal String ID;
terminal String ATTR_STRING;

/* Non-terminals */
non terminal Unit program;
non terminal List<Declaration> declStar;
non terminal Declaration decl;
non terminal TypeDeclaration     typeDecl;
non terminal ConstDeclaration    constantDecl;
non terminal FunctionDeclaration functionDecl;
non terminal Axiom               axiomDecl;
non terminal VariableDeclaration varDecl;
non terminal Procedure           procedureDecl; 
non terminal Procedure           implementationDecl;

non terminal Boolean uniqueOpt, completeOpt;
non terminal ParentEdge[] parentInfoOpt;
non terminal List<ParentEdge> parentEdgeCommaStar, parentEdgeCommaPlus;
non terminal ParentEdge parentEdge;

non terminal List<VarList> fargCommaStar, fargCommaPlus;
non terminal VarList returnSpec;
non terminal VarList farg;
non terminal Expression fbodyOpt;


non terminal List<VarList> poutparmOpt, ioutparmOpt;
non terminal List<Specification> specStar;
non terminal Specification spec;
non terminal Boolean freeOpt;

non terminal NamedAttribute[] attributes;
non terminal List<Expression> attrArgCommaPlus, attrArgCommaStar;
non terminal List<NamedAttribute>  attributeStar;
non terminal List<Attribute> attrtriggers;
non terminal NamedAttribute attribute;
non terminal Trigger trigger;
non terminal Expression attrArg;

non terminal ASTType  type, typeAtom, mapType;
non terminal String[] typeArgsOpt;
non terminal List<ASTType> typeCtorArgsOpt, typeCommaList;


non terminal List<Expression> exprCommaPlus, exprCommaStar;
non terminal Expression expr, expr1, expr2, expr3, expr4, expr5; 
non terminal Expression expr6, expr7, expr8, expr9;
non terminal Expression exprImplies, exprAnd, exprOr;
non terminal Expression expr1NI, expr2NI, expr3NI, expr4NI, expr5NI; 
non terminal Expression expr6NI, expr7NI, expr8NI, expr9NI;
non terminal Expression exprImpliesNI, exprExpliesNI, exprAndNI, exprOrNI;
non terminal Boolean quant;

non terminal List<VariableDeclaration>   localVarDeclStar;
non terminal List<Statement> stmtList;
non terminal Body        body;
non terminal VariableDeclaration localVarDecl;
non terminal Statement   stmt;
non terminal List<Expression>   wildcardExprCommaPlus, wildcardExprCommaStar;
non terminal List<LeftHandSide> lhsCommaPlus;
non terminal Expression   wildcardExpr;
non terminal LeftHandSide lhs;
non terminal Statement[] blockStmt;
non terminal Statement   ifStmt;
non terminal Statement[] elseOpt;
non terminal List<LoopInvariantSpecification> loopInvStar;
non terminal LoopInvariantSpecification loopInv;

non terminal List<String> idStar, idCommaStar, idCommaPlus;
non terminal List<VarList> idsTypeCommaPlus, idsTypeCommaStar;
non terminal List<VarList> idsTypeWhereCommaPlus, idsTypeWhereCommaStar;
non terminal VarList idsType, idsTypeWhere;
non terminal Expression whereClauseOpt;

/* The grammar */

program ::=
	declStar:d
	{: RESULT = new Unit(d.toArray(new Declaration[d.size()])); :}
	;

declStar ::=
      /* empty */ {: RESULT = new LinkedList<Declaration>(); :}
    | declStar:p decl:d {: p.add(d); RESULT = p; :}
    | declStar:p error {: RESULT = p; :} 
    ;
    
decl ::=
	  typeDecl:d {: RESULT = d; :}
	| constantDecl:d {: RESULT = d; :}
	| functionDecl:d {: RESULT = d; :}
	| axiomDecl:d {: RESULT = d; :}
	| varDecl:d {: RESULT = d; :}
	| procedureDecl:d {: RESULT = d; :}
	| implementationDecl:d {: RESULT = d; :}
	;

/* type decl */

typeDecl ::=
	TYPE:x attributes:attr ID:name idStar:param EQUALS type:t SEMI
	  {:/* Set isFinite to true; we do not know whether it is finite */
	    RESULT = new TypeDeclaration
	    (parser.filename, x$.left, attr, true, name, param.toArray(new String[param.size()]), t); :}
	| TYPE:x attributes:attr FINITE ID:name idStar:param SEMI
	  {:RESULT = new TypeDeclaration
	    (parser.filename, x$.left, attr, true, name, param.toArray(new String[param.size()]), null); :}
	| TYPE:x attributes:attr ID:name idStar:param SEMI
	  {:RESULT = new TypeDeclaration
	    (parser.filename, x$.left, attr, false, name, param.toArray(new String[param.size()]), null); :}
	;
	
/* constant decl */

constantDecl ::=
	CONST:x attributes:attr uniqueOpt:u idsType:vl parentInfoOpt:p completeOpt:c SEMI
	  {:RESULT = new ConstDeclaration(parser.filename, x$.left, attr, u, vl, p, c); :}
    ;
uniqueOpt ::=
      /* EMPTY */ {: RESULT = false; :}
    | UNIQUE {: RESULT = true; :}
    ;
completeOpt ::=
      /* EMPTY */ {: RESULT = false; :}
    | COMPLETE {: RESULT = true; :}
    ;
parentInfoOpt ::=
      /* EMPTY */ {: RESULT = null; :}
    | PARTORDER:x parentEdgeCommaStar:pel
      {: RESULT = pel.toArray(new ParentEdge[pel.size()]); :}
    ;
parentEdgeCommaStar ::=
      /* EMPTY */ {: RESULT = Collections.emptyList(); :}
	| parentEdgeCommaPlus:pel {: RESULT = pel; :}
	;
parentEdgeCommaPlus ::=
	  parentEdge: p
		{: RESULT = new LinkedList<ParentEdge>(); RESULT.add(p); :}
	| parentEdgeCommaPlus:pel COMMA parentEdge:p
		{: RESULT = pel; RESULT.add(p); :}
	;
parentEdge ::=
	  uniqueOpt:u ID:i {: RESULT = new ParentEdge(u, i); :}
	;

/* axiom decl */
axiomDecl ::=
	AXIOM:x attributes:attr expr:e SEMI
	{: RESULT = new Axiom(parser.filename, x$.left, attr, e); :}
	;
	
/* function decl */
functionDecl ::=
	  FUNCTION:x attributes:attr ID:i 
		typeArgsOpt:ta LPAR fargCommaStar:p RPAR returnSpec:r
		fbodyOpt:b
	  {: RESULT = new FunctionDeclaration
		(parser.filename, x$.left, attr, i, ta, p.toArray(new VarList[p.size()]), r, b); :}
	;
fbodyOpt ::=
	SEMI {: RESULT = null; :}
	| LBRC expr:e RBRC {: RESULT = e; :}
	;
fargCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| fargCommaPlus:f {: RESULT = f; :}
	;
fargCommaPlus ::=
	farg:f {: RESULT = new LinkedList<VarList>(); RESULT.add(f); :}
	| fargCommaPlus:fl COMMA farg:f {: RESULT = fl; RESULT.add(f); :}
	;
returnSpec ::=
	RETURNS LPAR farg:r RPAR
	  {: RESULT = r; :}
	| COLON type:t 
	  {: RESULT = new VarList(new String[0], t, null); :}
	;  
farg ::=
	ID:i COLON type:t
	  {: RESULT = new VarList(new String[] { i }, t, null); :}
	| type:t
	  {: RESULT = new VarList(new String[0], t, null); :}
	;  

/* var decl */
varDecl ::=
    VAR:x attributes:attr idsTypeWhereCommaPlus:vlist SEMI
    {: RESULT = new VariableDeclaration(parser.filename, x$.left, attr, vlist.toArray(new VarList[vlist.size()])); :}
    ;

/* procedure and implementation decl */

procedureDecl ::=
	  PROCEDURE:x attributes:attr ID:i 
	    typeArgsOpt:ta LPAR idsTypeWhereCommaStar:param RPAR poutparmOpt:outp
	    SEMI specStar:s
	  {: RESULT = new Procedure(parser.filename, x$.left, attr, i, ta, param.toArray(new VarList[param.size()]), outp.toArray(new VarList[outp.size()]), s.toArray(new Specification[s.size()]), null); :}
	| PROCEDURE:x attributes:attr ID:i 
	    typeArgsOpt:ta LPAR idsTypeWhereCommaStar:param RPAR poutparmOpt:outp
	    specStar:s body:b
	  {: RESULT = new Procedure(parser.filename, x$.left, attr, i, ta, param.toArray(new VarList[param.size()]), outp.toArray(new VarList[outp.size()]), s.toArray(new Specification[s.size()]), b); :}
	;
implementationDecl ::=
	  IMPLEMENTATION:x attributes:attr ID:i
	    typeArgsOpt:ta LPAR idsTypeCommaStar:param RPAR ioutparmOpt:out
	    body:b
	  {: RESULT = new Procedure(parser.filename, x$.left, attr, i, ta, param.toArray(new VarList[param.size()]), out.toArray(new VarList[out.size()]), null, b); :}
	;

poutparmOpt ::=
	  /* empty */ {: RESULT = Collections.emptyList(); :}
	| RETURNS LPAR idsTypeWhereCommaStar:l RPAR
	  {: RESULT = l; :}
	;
ioutparmOpt ::=
	  /* empty */ {: RESULT = Collections.emptyList(); :}
	| RETURNS LPAR idsTypeCommaStar:l RPAR
	  {: RESULT = l; :}
	;
specStar ::=
	  /* empty */ {: RESULT = new LinkedList<Specification>(); :}
	| specStar:l spec:s {: RESULT = l; l.add(s); :}
	; 
spec ::=
	  freeOpt:free REQUIRES:x expr:e SEMI
	  {: RESULT = new RequiresSpecification(parser.filename, x$.left, free, e); :}
	| freeOpt:free ENSURES:x expr:e SEMI
	  {: RESULT = new EnsuresSpecification(parser.filename, x$.left, free, e); :}
	| freeOpt:free MODIFIES:x idCommaStar:l SEMI
	  {: RESULT = new ModifiesSpecification(parser.filename, x$.left, free, l.toArray(new String[l.size()])); :}
	;
freeOpt ::=
	  /* empty */ {: RESULT = false; :}
	| FREE:x {: RESULT = true; :}
	;
	
/* attributes */
attributes ::=
	attributeStar:as {: RESULT = as.toArray(new NamedAttribute[as.size()]); :};

attributeStar ::=
	/* empty */ {: RESULT = new LinkedList<NamedAttribute>(); :}
	| attributeStar:as attribute:a {: as.add(a); RESULT = as; :}
	;
attrtriggers ::=
	/* empty */ {: RESULT = new LinkedList<Attribute>(); :}
	| attrtriggers:as attribute:a {: as.add(a); RESULT = as; :}
	| attrtriggers:as trigger:t {: as.add(t); RESULT = as; :}
	;
attribute ::=
	LBRC:x COLON ID:name attrArgCommaStar:attr RBRC
	  {: RESULT = new NamedAttribute(name, attr.toArray(new Expression[attr.size()])); :}
	;
attrArgCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| attrArgCommaPlus:al {: RESULT = al; :}
	;
attrArgCommaPlus ::=
	attrArg:a {: RESULT = new LinkedList<Expression>(); RESULT.add(a); :}
	| attrArgCommaPlus:al COMMA attrArg:a {: RESULT = al; al.add(a); :}
	;
	
attrArg ::=
	expr:e {: RESULT = e; :}
	| ATTR_STRING:s {: RESULT = new StringLiteral(s); :}
	;

trigger ::= 
	LBRC:x exprCommaPlus:el RBRC
	  {: RESULT = new Trigger(el.toArray(new Expression[el.size()])); :}
	;

/* types */

typeCommaList ::= 
	  type:t {: RESULT = new LinkedList<ASTType>(); RESULT.add(t); :}
	| typeCommaList:tl COMMA type:t {: tl.add(t); RESULT = tl; :}
	;
type ::= 
	  typeAtom:t {: RESULT = t; :}
	| mapType:t {: RESULT = t; :}
	| ID:i typeCtorArgsOpt:args
	  {:RESULT = new NamedType(i, args.toArray(new ASTType[args.size()])); :}
	;
typeAtom ::= 
	BOOL:x {: RESULT = new PrimitiveType("bool"); :}
	| INT:x {: RESULT = new PrimitiveType("int"); :}
	| REAL:x {: RESULT = new PrimitiveType("real"); :}
	| BVTYPE:bv  {: RESULT = new PrimitiveType(bv); :}
	| LPAR type:t RPAR {: RESULT = t; :};
mapType ::=
	typeArgsOpt:ta LBKT:x typeCommaList:tL RBKT type:t
	  {: RESULT = new ArrayType(ta, tL.toArray(new ASTType[tL.size()]), t); :}
	;
typeArgsOpt ::=
	  /*empty*/
	  {: RESULT = new String[0]; :}
	| LANG:x idCommaPlus:tal RANG
	  {: RESULT = tal.toArray(new String[tal.size()]); :}
	| LESS:x idCommaPlus:tal GREATER
	  {: RESULT = tal.toArray(new String[tal.size()]); :}
	;
typeCtorArgsOpt ::=
	  /* empty */ {:RESULT = new LinkedList<ASTType>(); :}
	| typeAtom:ta typeCtorArgsOpt:tl {:  tl.add(0, ta); RESULT = tl; :}
	| ID:i typeCtorArgsOpt:tl
	  {: tl.add(0, new NamedType(i, new ASTType[0])); RESULT = tl; :}
	| mapType:t
	  {: RESULT = new LinkedList<ASTType>(); RESULT.add(t); :}
	; 

/* expressions */

exprCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| exprCommaPlus:l {: RESULT = l; :}
	;

exprCommaPlus ::=
	  expr:e
	  {: RESULT = new LinkedList<Expression>(); RESULT.add(e); :}
	| exprCommaPlus:el COMMA expr:e
	  {: el.add(e); RESULT = el; :}
	;

expr  ::= expr1NI:e1 IFF expr:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIFF, e1, e2);:}
        | expr1:e {: RESULT = e; :}
        ;
expr1 ::= expr2NI:e1 IMPLIES exprImplies:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e1, e2);:}
        | exprExpliesNI:e1 EXPLIES expr2:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e2, e1);:}
        | expr2:e {: RESULT = e; :}
        ;
exprImplies ::= expr2NI:e1 IMPLIES exprImplies:e2
            {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e1, e2);:}
          | expr2:e
            {:RESULT = e;:}
          ;
expr2 ::= expr3NI:e1 AND exprAnd:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICAND, e1, e2);:}
        | expr3NI:e1 OR  exprOr:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICOR, e1, e2);:}
        | expr3:e
          {:RESULT = e;:}
        ;
exprAnd ::= expr3NI:e1 AND exprAnd:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICAND, e1, e2);:}
          | expr3:e
            {:RESULT = e;:}
          ;
exprOr ::= expr3NI:e1 OR exprOr:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICOR, e1, e2);:}
          | expr3:e
            {:RESULT = e;:}
          ;
expr3 ::= expr4NI:e1 LESS expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPLT, e1, e2);:}
        | expr4NI:e1 GREATER expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPGT, e1, e2);:}
        | expr4NI:e1 LTEQ expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPLEQ, e1, e2);:}
        | expr4NI:e1 GTEQ expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPGEQ, e1, e2);:}
        | expr4NI:e1 EQ expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPEQ, e1, e2);:}
        | expr4NI:e1 NEQ expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPNEQ, e1, e2);:}
        | expr4NI:e1 PARTORDER expr4:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPPO, e1, e2);:}
        | expr4:e {: RESULT = e; :}
        ;
expr4 ::= expr4NI:e1 CONCAT expr5:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.BITVECCONCAT, e1, e2);:}
        | expr5:e {: RESULT = e; :}
        ;
expr5 ::= expr5NI:e1 PLUS expr6:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHPLUS, e1, e2);:}
        | expr5NI:e1 MINUS expr6:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMINUS, e1, e2);:}
        | expr6:e {: RESULT = e; :}
        ;
        
expr6 ::= expr6NI:e1 TIMES expr7:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMUL, e1, e2);:}
        | expr6NI:e1 DIVIDE expr7:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHDIV, e1, e2);:}
        | expr6NI:e1 MOD expr7:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMOD, e1, e2);:}
        | expr7:e {: RESULT = e; :}
        ;
expr7 ::= NOT:x   expr7:e
           {:RESULT = new UnaryExpression(UnaryExpression.Operator.LOGICNEG, e);:}
        | MINUS:x expr7:e
           {:RESULT = new UnaryExpression(UnaryExpression.Operator.ARITHNEGATIVE, e);:}
        | expr8:e {: RESULT = e; :}
        ;
expr8 ::= expr8NI:e1 LBKT:x exprCommaPlus:e2 RBKT
          {:RESULT = new ArrayAccessExpression
		(e1, e2.toArray(new Expression[e2.size()])); :}
        | expr8NI:e1 LBKT:x exprCommaPlus:e2 COLONEQUALS expr:e RBKT
          {:RESULT = new ArrayStoreExpression
		(e1, e2.toArray(new Expression[e2.size()]), e); :}
        | expr8NI:e1 LBKT NUMBER:e2 COLON NUMBER:e3 RBKT
          {:RESULT = new BitVectorAccessExpression
		(e1, Integer.parseInt(e2), Integer.parseInt(e3)); :}
        | expr9:e
          {:RESULT = e;:}
        ;
expr9 ::= 
	  FALSE:x
	  {: RESULT = new BooleanLiteral(false); :}
	| TRUE:x
	  {: RESULT = new BooleanLiteral(true); :}
	| NUMBER:n
	  {: RESULT = new IntegerLiteral(n); :}
	| REALNUMBER:n
	  {: RESULT = new RealLiteral(n); :}
	| BITVECTOR:bv
	  {: RESULT = parseBitvec(bv); :}
	| ID:i
	  {: RESULT = new IdentifierExpression(i); :}
	| ID:i LPAR exprCommaStar:args RPAR
	  {: RESULT = new FunctionApplication(i, args.toArray(new Expression[args.size()])); :}
	| OLD:x LPAR expr:e RPAR
	  {: RESULT = new UnaryExpression(UnaryExpression.Operator.OLD, e); :}
	| LPAR:x quant:q typeArgsOpt:ta idsTypeCommaPlus:vars QSEP attrtriggers:a expr:e RPAR
	  {: RESULT = new QuantifierExpression(q, ta, vars.toArray(new VarList[vars.size()]), a.toArray(new Attribute[a.size()]), e); :}
	| IF expr:c THEN expr:t ELSE expr:e 
	  {: RESULT = new IfThenElseExpression(c, t, e); :}
	| LPAR expr:e RPAR
	  {: RESULT = e;:}
	;
	
/* expressions  without if-then-else*/

expr1NI ::= expr2NI:e1 IMPLIES exprImpliesNI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e1, e2);:}
        | exprExpliesNI:e1 EXPLIES expr2NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e2, e1);:}
        | expr2NI:e {: RESULT = e; :}
        ;
exprImpliesNI ::= expr2NI:e1 IMPLIES exprImpliesNI:e2
            {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e1, e2);:}
          | expr2NI:e
            {:RESULT = e;:}
          ;
exprExpliesNI ::= exprExpliesNI:e1 EXPLIES expr2NI:e2
            {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICIMPLIES, e2, e1);:}
          | expr2NI:e
            {:RESULT = e;:}
          ;
expr2NI ::= expr3NI:e1 AND exprAndNI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICAND, e1, e2);:}
        | expr3NI:e1 OR  exprOrNI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICOR, e1, e2);:}
        | expr3NI:e
          {:RESULT = e;:}
        ;
exprAndNI ::= expr3NI:e1 AND exprAndNI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICAND, e1, e2);:}
          | expr3NI:e
            {:RESULT = e;:}
          ;
exprOrNI ::= expr3NI:e1 OR exprOrNI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.LOGICOR, e1, e2);:}
          | expr3NI:e
            {:RESULT = e;:}
          ;
expr3NI ::= expr4NI:e1 LESS expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPLT, e1, e2);:}
        | expr4NI:e1 GREATER expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPGT, e1, e2);:}
        | expr4NI:e1 LTEQ expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPLEQ, e1, e2);:}
        | expr4NI:e1 GTEQ expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPGEQ, e1, e2);:}
        | expr4NI:e1 EQ expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPEQ, e1, e2);:}
        | expr4NI:e1 NEQ expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPNEQ, e1, e2);:}
        | expr4NI:e1 PARTORDER expr4NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.COMPPO, e1, e2);:}
        | expr4NI:e {: RESULT = e; :}
        ;
expr4NI ::= expr4NI:e1 CONCAT expr5NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.BITVECCONCAT, e1, e2);:}
        | expr5NI:e {: RESULT = e; :}
        ;
expr5NI ::= expr5NI:e1 PLUS expr6NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHPLUS, e1, e2);:}
        | expr5NI:e1 MINUS expr6NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMINUS, e1, e2);:}
        | expr6NI:e {: RESULT = e; :}
        ;
        
expr6NI ::= expr6NI:e1 TIMES expr7NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMUL, e1, e2);:}
        | expr6NI:e1 DIVIDE expr7NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHDIV, e1, e2);:}
        | expr6NI:e1 MOD expr7NI:e2
           {:RESULT = new BinaryExpression(BinaryExpression.Operator.ARITHMOD, e1, e2);:}
        | expr7NI:e {: RESULT = e; :}
        ;
expr7NI ::= NOT:x   expr7NI:e
           {:RESULT = new UnaryExpression(UnaryExpression.Operator.LOGICNEG, e);:}
        | MINUS:x expr7NI:e
           {:RESULT = new UnaryExpression(UnaryExpression.Operator.ARITHNEGATIVE, e);:}
        | expr8NI:e {: RESULT = e; :}
        ;
expr8NI ::= expr8NI:e1 LBKT:x exprCommaPlus:e2 RBKT
          {:RESULT = new ArrayAccessExpression
		(e1, e2.toArray(new Expression[e2.size()])); :}
        | expr8NI:e1 LBKT:x exprCommaPlus:e2 COLONEQUALS expr:e RBKT
          {:RESULT = new ArrayStoreExpression
		(e1, e2.toArray(new Expression[e2.size()]), e); :}
        | expr8NI:e1 LBKT NUMBER:e2 COLON NUMBER:e3 RBKT
          {:RESULT = new BitVectorAccessExpression
		(e1, Integer.parseInt(e2), Integer.parseInt(e3)); :}
        | expr9NI:e
          {:RESULT = e;:}
        ;
expr9NI ::= 
	  FALSE:x
	  {: RESULT = new BooleanLiteral(false); :}
	| TRUE:x
	  {: RESULT = new BooleanLiteral(true); :}
	| NUMBER:n
	  {: RESULT = new IntegerLiteral(n); :}
	| REALNUMBER:n
	  {: RESULT = new RealLiteral(n); :}
	| BITVECTOR:bv
	  {: RESULT = parseBitvec(bv); :}
	| ID:i
	  {: RESULT = new IdentifierExpression(i); :}
	| ID:i LPAR exprCommaStar:args RPAR
	  {: RESULT = new FunctionApplication(i, args.toArray(new Expression[args.size()])); :}
	| OLD:x LPAR expr:e RPAR
	  {: RESULT = new UnaryExpression(UnaryExpression.Operator.OLD, e); :}
	| LPAR:x quant:q typeArgsOpt:ta idsTypeCommaPlus:vars QSEP attrtriggers:a expr:e RPAR
	  {: RESULT = new QuantifierExpression(q, ta, vars.toArray(new VarList[vars.size()]), a.toArray(new Attribute[a.size()]), e); :}
	| LPAR expr:e RPAR
	  {: RESULT = e;:}
	;
quant ::=
	  FORALL {: RESULT = true; :}
	| EXISTS {: RESULT = false; :}
	;

/* implementation body */
body ::= LBRC:x localVarDeclStar:lv stmtList:s RBRC
	  {: RESULT = new Body(lv.toArray(new VariableDeclaration[lv.size()]),
			 s.toArray(new Statement[s.size()])); :}
	;
localVarDeclStar ::=
	  /* empty */ {: RESULT = new LinkedList<VariableDeclaration>(); :}
	| localVarDeclStar:lvl localVarDecl:lv {: lvl.add(lv); RESULT = lvl; :}
	;
localVarDecl ::=
	  VAR:x attributes:attr idsTypeWhereCommaPlus:i SEMI
	  {: RESULT = new VariableDeclaration(parser.filename, x$.left, attr, i.toArray(new VarList[i.size()])); :}
	;
stmtList ::=
	  /* empty */ {: RESULT = new LinkedList<Statement>(); :}
	| stmtList:l stmt:s {: l.add(s); RESULT = l; :}
	;
stmt ::=
	  ID:i COLON
	  {: RESULT = new Label(parser.filename, i$.left, i); :}
	| ASSERT:x expr:e SEMI
	  {: RESULT = new AssertStatement(parser.filename, x$.left, e); :}
	| ASSUME:x expr:e SEMI
	  {: RESULT = new AssumeStatement(parser.filename, x$.left, e); :}
	| HAVOC:x idCommaPlus:i SEMI
	  {: RESULT = new HavocStatement(parser.filename, x$.left, i.toArray(new String[i.size()])); :}
	| lhsCommaPlus:lhs COLONEQUALS exprCommaPlus:rhs SEMI
	  {: RESULT = new AssignmentStatement
		(parser.filename, lhs$.left, lhs.toArray(new LeftHandSide[lhs.size()]), rhs.toArray(new Expression[rhs.size()])); :}
	| CALL:x ID:m LPAR:y exprCommaStar:e RPAR SEMI
	  {: RESULT = new CallStatement(parser.filename, x$.left, false, new String[0], m, e.toArray(new Expression[e.size()])); :}

	| CALL:x idCommaPlus:ass COLONEQUALS ID:m LPAR exprCommaStar:p RPAR SEMI
	  {: RESULT = new CallStatement(parser.filename, x$.left, false, ass.toArray(new String[ass.size()]), m, p.toArray(new Expression[p.size()])); :}
	| CALL:x FORALL:z ID:m LPAR wildcardExprCommaStar:e RPAR SEMI
	  {: RESULT = new CallStatement(parser.filename, x$.left, true, new String[0], m, e.toArray(new Expression[e.size()])); :}
	| ifStmt:s {: RESULT = s; :}
	| WHILE:x LPAR wildcardExpr:c RPAR loopInvStar:inv blockStmt:block
	  {: RESULT = new WhileStatement(parser.filename, x$.left, c, inv.toArray(new LoopInvariantSpecification[inv.size()]), block); :}
	| BREAK:x SEMI
	  {: RESULT = new BreakStatement(parser.filename, x$.left); :}
	| BREAK:x ID:label SEMI
	  {: RESULT = new BreakStatement(parser.filename, x$.left, label); :}
	| RETURN:x SEMI
	  {: RESULT = new ReturnStatement(parser.filename, x$.left); :}
	| GOTO:x idCommaPlus:l SEMI
	  {: RESULT = new GotoStatement(parser.filename, x$.left, l.toArray(new String[l.size()])); :}
	;
ifStmt ::=
	  IF:x LPAR wildcardExpr:c RPAR blockStmt:block elseOpt:e
	  {: RESULT = new IfStatement(parser.filename, x$.left, c, block, e); :}
	;
elseOpt ::=
	  /* empty */ {: RESULT = new Statement[0]; :}
	| ELSE blockStmt:block {: RESULT = block; :}
	| ELSE ifStmt:s {: RESULT = new Statement[] { s }; :}
	;
blockStmt ::=
	  LBRC:x stmtList:s RBRC
	  {: RESULT = s.toArray(new Statement[s.size()]); :}
	;
loopInvStar ::=
	  /* empty */ {: RESULT = new LinkedList<LoopInvariantSpecification>(); :}
	| loopInvStar:l loopInv:i {: RESULT = l; l.add(i); :}
	;
loopInv ::=
	  freeOpt:free INVARIANT:x expr:e SEMI
	  {: RESULT = new LoopInvariantSpecification(parser.filename, x$.left, free, e); :}
	;
	
lhsCommaPlus ::=
	lhs:e
	  {: RESULT = new LinkedList<LeftHandSide>(); RESULT.add(e); :}
	| lhsCommaPlus:l COMMA lhs:e
	  {: RESULT = l; l.add(e); :}
	;
lhs ::=
	  ID:i
	  {: RESULT = new VariableLHS(i); :}
	| lhs:l LBKT:x exprCommaPlus:e RBKT
	  {: RESULT = new ArrayLHS(l, e.toArray(new Expression[e.size()])); :}
	;
wildcardExprCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| wildcardExprCommaPlus:l {: RESULT = l; :}
	;
wildcardExprCommaPlus ::=
	wildcardExpr:e
	  {: RESULT = new LinkedList<Expression>(); RESULT.add(e); :}
	| wildcardExprCommaPlus:l COMMA wildcardExpr:e
	  {: RESULT = l; l.add(e); :}
	;
wildcardExpr ::=
	expr:e {: RESULT = e; :}
	| TIMES:x {: RESULT = new WildcardExpression(); :}
	;

/* misc */
        
idStar ::= 
	  /*empty*/
	  {: RESULT = new LinkedList<String>(); :} 
	| idStar:il ID:i
	  {: il.add(i); RESULT = il; :} 
    ;
idCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| idCommaPlus:l {: RESULT = l; :}
	;
idCommaPlus ::= 
	  ID:i
	  {: RESULT = new LinkedList<String>(); RESULT.add(i); :} 
	| idCommaPlus:il COMMA ID:i
	  {: il.add(i); RESULT = il; :} 
    ;

idsTypeCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| idsTypeCommaPlus:il {: RESULT = il; :}
	;
idsTypeCommaPlus ::=
      idsType:i
      {: RESULT = new LinkedList<VarList>(); RESULT.add(i); :}
    | idsTypeCommaPlus:il COMMA idsType:i
      {: RESULT = il; RESULT.add(i); :}
    ;
idsType ::= idCommaPlus:i COLON type:t
	  {: RESULT = new VarList(i.toArray(new String[i.size()]),t); :}
	;

idsTypeWhereCommaStar ::=
	/* empty */ {: RESULT = Collections.emptyList(); :}
	| idsTypeWhereCommaPlus:il {: RESULT = il; :}
	;
idsTypeWhereCommaPlus ::=
      idsTypeWhere:i
      {: RESULT = new LinkedList<VarList>(); RESULT.add(i); :}
    | idsTypeWhereCommaPlus:il COMMA idsTypeWhere:i
      {: RESULT = il; RESULT.add(i); :}
    ;
idsTypeWhere ::= idCommaPlus:i COLON type:t whereClauseOpt:w
	  {: RESULT = new VarList(i.toArray(new String[i.size()]), t, w); :}
	;
whereClauseOpt ::=
	  /* empty */ {: RESULT = null; :}
	| WHERE:x expr:e {: RESULT = e; :}
	;
