/* CUP specification for smtlib */

package local.stalin.smt.smtlib;
import local.stalin.logic.*;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.Stack;
import org.apache.log4j.Logger;
import java_cup.runtime.Symbol;

parser Parser;
option symbols = LexerSymbols;
option java15, compact_red, newpositions;

parser code {:
	String filename;
	public void setFileName(String filename) {
		this.filename = filename;
	}
	
	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof MySymbolFactory.LineColumnSymbol) {
			MySymbolFactory.LineColumnSymbol bsym = (MySymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
	    } else if ((sym instanceof Symbol) 
	    	       && ((Symbol)sym).sym == LexerSymbols.EOF) {
	    	location = "EOF";
	    } else
	        location = "UNKNOWN";
	    
		Logger.getRootLogger().error(filename+":"+location+": "+s);
	}

	public void report_error(String s) {	
		report_error(s, cur_token);
	}
	Theory theory = null;
	public void setTheory(Theory theory) {
		this.theory = theory;
	}
:}

action code {:
	Stack<TermVariable> varScopes = new Stack<TermVariable>();
	Stack<FormulaVariable> fvarScopes = new Stack<FormulaVariable>();
	Theory theory = new Theory();
	Benchmark benchmark = new Benchmark(theory);
	Sort errorSort = theory.createSort("*error*");
	
	public Sort lookupSort(Symbol sym, String name) {
		Sort s = theory.getSort(name);
		if (s == null)
			parser.report_error("Undeclared sort "+name, sym);
		return s;
	}

	public TermVariable findVar(String name) {
		ListIterator<TermVariable> it = varScopes.listIterator(varScopes.size());
		while (it.hasPrevious()) {
			TermVariable tv = it.previous();
			if (tv.getName().equals(name))
				return tv;
		}
		Logger.getRootLogger().error("Undeclared variable "+name);
		return theory.createTermVariable(name, errorSort);
	}
	
	public FormulaVariable findFvar(String name) {
		ListIterator<FormulaVariable> it = fvarScopes.listIterator(fvarScopes.size());
		while (it.hasPrevious()) {
			FormulaVariable fv = it.previous();
			if (fv.getName().equals(name))
				return fv;
		}
		Logger.getRootLogger().error("Undeclared form variable "+name);
		return theory.createFormulaVariable(name);
	}
	
	private Atom createAtomInternal(String pred, List<Term> params) {
		Term[] terms = params.toArray(new Term[params.size()]);
		Sort[] sorts = new Sort[terms.length];
		for (int i = 0; i < terms.length; i++) {
			sorts[i] = terms[i].getSort();
		}
		PredicateSymbol symb = theory.getPredicate(pred, sorts);
		if (symb == null)
			return null;
		return theory.atom(symb, terms);
	}
	
	private Term createFuncTermInternal(String f, List<Term> param) {
		Term[] terms = param.toArray(new Term[param.size()]);
		Sort[] sorts = new Sort[terms.length];
		for (int i = 0; i < sorts.length; i++) {
			sorts[i] = terms[i].getSort();
		}
		FunctionSymbol fsym = theory.getFunction(f, sorts);
		if (fsym == null) {
			if (terms.length == 0) {
			    return null;
			}
			/* Check if all sorts are equal and there is a binary function term */
			for (int i = 1; i < sorts.length; i++) {
				if (!sorts[i].equals(sorts[0])) {
					return null;
				}
			}
			/* Get binary function term */
			fsym = theory.getFunction(f, new Sort[] { sorts[0], sorts[0] });
			if (fsym == null || !fsym.getReturnSort().equals(sorts[0])) {
				return null;
			}
			/* Create nested application  (left-associative) */
			Term t = terms[0];
			for (int i = 1; i < terms.length; i++)
				t = theory.term(fsym, t, terms[i]);
			return t;
		}
		return theory.term(fsym, terms);
	}	
	
	public Term createFuncTerm(Symbol fsym, List<Term> param) {
		Term result = createFuncTermInternal((String) fsym.value, param);
		if (result == null) {
			parser.report_error("Undeclared function symbol "+fsym.value, fsym);
		}
		return result;
	}

	public Atom createAtom(Symbol psym, List<Term> params) {
		Atom result = createAtomInternal((String) psym.value, params);
		if (result == null) {
			parser.report_error("Undeclared predicate "+psym.value, psym);
		}
		return result;
	}
	
  	public SMTLibBase createTrigger(Symbol sym, List<Term> param) {
  		String id = (String)sym.value;
  		Term resultTerm = createFuncTermInternal(id, param);
  		if (resultTerm != null)
  			return resultTerm;
  		Atom resultAtom = createAtomInternal(id, param);
  		if (resultAtom == null) { 
  			parser.report_error("Undeclared symbol "+id, sym);
  		}
  		return resultAtom;
  	}
:}

init with {: if (theory != null) { action_obj.theory = theory; action_obj.benchmark = new Benchmark(theory); } :} 
scan with {: return getScanner().next_token(); :}


/* Keywords */
terminal EQUALS,AND,BENCHMARK,DISTINCT,EXISTS,FALSE,FLET,FORALL,IF_THEN_ELSE,IFF,IMPLIES;
terminal ITE,LET,LOGIC,NOT,OR,SAT,THEORY,TRUE,UNKNOWN,UNSAT,XOR;
terminal String VAR, FVAR, ATTRIBUTE, USERVAL, ID, INDEXED_ID, NUMERAL, RATIONAL;
terminal String ARITH_SYMB, ATTR_STRING;
terminal ATTR_ASSUMPTION, ATTR_LOGIC, ATTR_FORMULA, ATTR_STATUS;
terminal ATTR_EXTRASORTS, ATTR_EXTRAFUNS, ATTR_EXTRAPREDS, ATTR_NOTES;
terminal LPAR, RPAR;
terminal ATTR_PATTERN, LCPAR, RCPAR;

non terminal List<SMTLibBase[]> patternStar;
non terminal List<SMTLibBase> patPlus, patStar;
non terminal SMTLibBase pattern;
non terminal List<Formula> formulaPlus, formulaStar;
non terminal Formula formula;
non terminal List<TermVariable> quantVarPlus;
non terminal TermVariable quantVar;
non terminal Integer connective;
non terminal Atom atom, prop_atom;
non terminal List<Sort> sort_symbStar;
non terminal Sort sort_symb;
non terminal String pred_symb, fun_symb;
non terminal HashMap<String,String> annotationStar, annotationStar2;
non terminal List<Term> termPlus, termStar;
non terminal Term term, base_term;
non terminal extraSortPlus, extraSort, extraFunPlus, extraFun, extraPredPlus, extraPred; 
non terminal bench_attribute, bench_attributeStar, status;
non terminal Benchmark benchmark;

benchmark ::= LPAR BENCHMARK ID:name bench_attributeStar RPAR
    {: RESULT = benchmark; :}
    ;
bench_attributeStar ::= | bench_attributeStar bench_attribute;
bench_attribute ::= 
	ATTR_LOGIC ID:logic {: theory.setLogic(logic); :}
	| ATTR_ASSUMPTION formula:f {: benchmark.addFormula(f); :}
	| ATTR_FORMULA formula:f {: benchmark.addFormula(f); :}
	| ATTR_STATUS status
	| ATTR_EXTRASORTS LPAR extraSortPlus RPAR
	| ATTR_EXTRAFUNS LPAR extraFunPlus RPAR
	| ATTR_EXTRAPREDS LPAR extraPredPlus RPAR
	| ATTR_NOTES ATTR_STRING:s {: benchmark.note(s); :}
	| ATTRIBUTE USERVAL
	| ATTRIBUTE
	;
status ::= SAT | UNSAT | UNKNOWN;
extraSortPlus ::= extraSort | extraSortPlus extraSort;
extraFunPlus ::= extraFun | extraFunPlus extraFun;
extraPredPlus ::= extraPred | extraPredPlus extraPred;
extraSort ::= ID:sort {: theory.createSort(sort); :};
extraFun ::= LPAR fun_symb:f sort_symbStar:psorts sort_symb:rsort annotationStar:a RPAR
	{: theory.createFunction(f, psorts.toArray(new Sort[psorts.size()]), rsort); :};
extraPred ::= LPAR fun_symb:f sort_symbStar:psorts annotationStar:a RPAR
	{: theory.createPredicate(f, psorts.toArray(new Sort[psorts.size()])); :};

formula ::= atom:a {: RESULT = a; :}
          | LPAR NOT formula:f annotationStar:a RPAR
            {: RESULT = theory.not(f);
               RESULT.setAnnotations(a); :}
          | LPAR IF_THEN_ELSE formula:fc formula:ft formula:fe annotationStar:a RPAR
            {: RESULT = theory.ifthenelse(fc, ft, fe);
               RESULT.setAnnotations(a); :}
          | LPAR IMPLIES formula:f1 formula:f2 annotationStar:a RPAR
            {: RESULT = theory.implies(f1, f2);
               RESULT.setAnnotations(a); :}
          | LPAR connective:c formulaPlus:fl  annotationStar:a RPAR
            {: ListIterator<Formula> it = fl.listIterator(fl.size());
               RESULT = it.previous();
               while (it.hasPrevious()) {
                   if (c == ConnectedFormula.AND)
                       RESULT = theory.and(it.previous(), RESULT);
                   else if (c == ConnectedFormula.OR)
                       RESULT = theory.or(it.previous(), RESULT);
                   else if (c == ConnectedFormula.IFF)
                       RESULT = theory.iff(it.previous(), RESULT);
                   else if (c == ConnectedFormula.XOR)
                       RESULT = theory.xor(it.previous(), RESULT);
               }
               RESULT.setAnnotations(a); :}
          | LPAR EXISTS quantVarPlus:vl formula:f patternStar:t annotationStar:a RPAR
            {: varScopes.setSize(varScopes.size() - vl.size());
               RESULT = theory.exists(vl.toArray(new TermVariable[vl.size()]), f,t.toArray(new SMTLibBase[t.size()][]));
               RESULT.setAnnotations(a); :}
          | LPAR FORALL quantVarPlus:vl formula:f patternStar:t annotationStar:a RPAR
            {: varScopes.setSize(varScopes.size() - vl.size());
               RESULT = theory.forall(vl.toArray(new TermVariable[vl.size()]), f,t.toArray(new SMTLibBase[t.size()][]));
               RESULT.setAnnotations(a); :}
          | LPAR LET LPAR VAR:v term:tv RPAR
          	  {: varScopes.push(theory.createTermVariable(v, tv.getSort())); :}
              formula:f annotationStar:a RPAR
              {: RESULT = theory.let(varScopes.pop(), tv, f);
               RESULT.setAnnotations(a); :}
          | LPAR FLET LPAR FVAR:v formula:fv RPAR 
          	  {: fvarScopes.push(theory.createFormulaVariable(v)); :}
              formula:f annotationStar:a RPAR
              {: RESULT = theory.flet(fvarScopes.pop(), fv, f);
               RESULT.setAnnotations(a); :}
          ;
formulaPlus ::= formulaStar:l formula:f {: RESULT = l; RESULT.add(f); :};
formulaStar ::= {: RESULT = new LinkedList<Formula>(); :}
              | formulaStar:l formula:f {: RESULT = l; RESULT.add(f); :};

quantVarPlus ::= quantVar:v 
                {: RESULT = new LinkedList<TermVariable>(); RESULT.add(v); varScopes.push(v);:}
              | quantVarPlus:l quantVar:v {: RESULT = l; RESULT.add(v); varScopes.push(v);:};
quantVar ::= LPAR VAR:v sort_symb:sort RPAR
	  {: RESULT = theory.createTermVariable(v, sort); :}
	;
connective ::= 
	  OR {: RESULT = ConnectedFormula.OR; :}
	| AND {: RESULT = ConnectedFormula.AND; :}
	| IFF {: RESULT = ConnectedFormula.IFF; :}
	| XOR {: RESULT = ConnectedFormula.XOR; :}
	;
	
atom ::=
	  prop_atom:pa {: RESULT = pa; :}
	| LPAR prop_atom:pa annotationStar:a RPAR
	  {: RESULT = pa; pa.setAnnotations(a); :}
	| LPAR EQUALS termPlus:tl annotationStar:a RPAR
	  {: RESULT = theory.equals(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); :}
	| LPAR DISTINCT termPlus:tl annotationStar:a RPAR
	  {: RESULT = theory.distinct(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); :}
	| LPAR pred_symb:pred termPlus:tl annotationStar:a RPAR
	  {: RESULT = createAtom(pred$, tl); 
	     RESULT.setAnnotations(a); :}
	;
prop_atom ::=
	  TRUE {: RESULT = Atom.TRUE; :}
	| FALSE {: RESULT = Atom.FALSE; :}
	| FVAR:f {: RESULT = theory.atom(findFvar(f)); :}
	| ID:pred {: List<Term> args = Collections.emptyList();
	             RESULT = createAtom(pred$, args); :}
	;
pred_symb ::=
	  ARITH_SYMB :s {: RESULT = s; :}
	| ID:s {: RESULT = s; :} 
	;
fun_symb ::=
	  ARITH_SYMB :s {: RESULT = s; :}
	| ID:s {: RESULT = s; :} 
	;
sort_symb ::=
	  ID:s {: RESULT = lookupSort(s$, s); :} 
	;
sort_symbStar ::= 
	  /* empty */ {: RESULT = new LinkedList<Sort>(); :}
	| sort_symbStar:l sort_symb:s {: RESULT = l; l.add(s); :}
	;
annotationStar ::= /* empty */ {: RESULT = null; :}
	| annotationStar2:l ATTRIBUTE:a {: RESULT = l; l.put(a, ""); :}
	| annotationStar2:l ATTRIBUTE:a USERVAL:u {: RESULT = l; l.put(a, u); :}
	;
annotationStar2 ::= /* empty */ {: RESULT = new HashMap<String,String>(); :}
	| annotationStar2:l ATTRIBUTE:a {: RESULT = l; l.put(a, ""); :}
	| annotationStar2:l ATTRIBUTE:a USERVAL:u {: RESULT = l; l.put(a, u); :}
	;

base_term ::=
       VAR:v {: RESULT = theory.term(findVar(v)); :}
     | NUMERAL:n {: RESULT = theory.numeral(n); :}
     | RATIONAL:n {: RESULT = theory.rational(n); :}
     | ID:id {: List<Term> args = Collections.emptyList();
                RESULT = createFuncTerm(id$, args); :}
     ;

term ::= base_term:t {: RESULT = t; :}
     | LPAR base_term:t annotationStar:a RPAR
       {: RESULT = t; t.setAnnotations(a); :}
     | LPAR fun_symb:f termPlus:param annotationStar:a RPAR
       {:RESULT = createFuncTerm(f$, param); RESULT.setAnnotations(a); :}
     | LPAR ITE formula:cond term:th term:el annotationStar:a RPAR
       {: RESULT = theory.ite(cond, th, el);
          RESULT.setAnnotations(a); :}
     ;
       
termPlus ::= termStar:l term:t {: RESULT = l; l.add(t); :};
termStar ::= /* EMPTY */ {: RESULT = new LinkedList<Term>(); :}
	 | termStar:l term:t {: RESULT = l; l.add(t); :};

patternStar ::= /* EMPTY */ {: RESULT = new LinkedList<SMTLibBase[]>(); :}
	| patternStar:p ATTR_PATTERN LCPAR patPlus:t RCPAR {: RESULT = p; p.add(t.toArray(new SMTLibBase[t.size()])); :}
	;
	
patPlus ::= patStar:l pattern:p {: RESULT = l; l.add(p); :};
patStar ::= /* EMPTY */ {: RESULT = new LinkedList<SMTLibBase>(); :}
	| patStar:l pattern: p {: RESULT = l; l.add(p); :};
	
pattern ::= LPAR EQUALS termPlus:tl annotationStar:a RPAR
	  {: RESULT = theory.equals(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); :}
	| LPAR DISTINCT termPlus:tl annotationStar:a RPAR
	  {: RESULT = theory.distinct(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); :}
	| LPAR ID:pred termPlus:tl annotationStar:a RPAR
	  {: RESULT = createTrigger(pred$, tl); 
	     RESULT.setAnnotations(a); :}
	;