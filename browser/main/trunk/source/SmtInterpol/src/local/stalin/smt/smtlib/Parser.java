
//----------------------------------------------------
// The following code was generated by CUP v0.12joho 20081115
// Mon Mar 21 10:47:49 CET 2011
//----------------------------------------------------

package local.stalin.smt.smtlib;

import local.stalin.logic.*;
import java.util.Collections;
import java.util.List;
import java.util.ListIterator;
import java.util.LinkedList;
import java.util.HashMap;
import java.util.Stack;
import org.apache.log4j.Logger;
import java_cup.runtime.Symbol;

/** CUP v0.12joho 20081115 generated parser.
  * @version Mon Mar 21 10:47:49 CET 2011
  */
public class Parser extends java_cup.runtime.LRParser {

  /** Default constructor. */
  public Parser() {super();}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s) {super(s);}

  /** Constructor which sets the default scanner. */
  public Parser(java_cup.runtime.Scanner s, java_cup.runtime.SymbolFactory sf) {super(s,sf);}
  /** Return action table */
  protected String[] action_table() { 
    return new String[] {
    "\260\000\002\040\005\036\000\036\002\035\002" +
    "\035\002\035\002\035\002\035\004\035\004\035" +
    "\004\035\002\035\002\035\001\037\001\037\001" +
    "\037\001\027\001\027\002\031\001\031\002\033" +
    "\001\033\002\030\001\032\006\034\005\007\001" +
    "\007\005\007\007\007\006\007\005\007\007\007" +
    "\007\007\012\041\000\007\012\042\000\005\002" +
    "\006\000\006\002\010\001\010\002\011\004\012" +
    "\001\012\001\012\001\012\001\013\001\013\004" +
    "\013\005\013\005\013\005\014\001\014\001\014" +
    "\001\014\001\017\001\017\001\020\001\020\001" +
    "\016\001\015\000\015\002\021\000\021\002\021" +
    "\003\022\000\022\002\022\003\026\001\026\001" +
    "\026\001\026\001\025\001\025\004\025\005\025" +
    "\007\023\002\024\000\024\002\001\000\001\005" +
    "\002\002\003\000\003\002\004\005\004\005\004" +
    "\005\274\u026c\342\334\u01d8\274\334\u022e\u010e\u0166" +
    "\u01b4\u015e\u027c\u026a\u025e\u025c\u01d8\274\274\274\274" +
    "\274\274\274\u01ea\274\274\274\274\274\274\274" +
    "\274\274\u01b0\u0258\u024e\274\332\274\330\u024a\u0248" +
    "\u020a\u0146\274\u013e\u0202\u0130\274\274\u0266\274\326" +
    "\u0264\324\274\u0152\274\u0198\u01c0\274\u0112\u0188\274" +
    "\u0262\u021c\u0260\336\u0128\274\346\u0110\u0108\372\274" +
    "\u025e\u0258\362\u0298\372\u0254\274\274\274\274\u0194" +
    "\274\274\322\274\274\u0296\274\274\274\274\u01f4" +
    "\u024e\274\u0294\u0178\u01b2\320\274\324\310\322\u023a" +
    "\u0212\u0292\u0290\u0238\274\u016c\u028e\u0164\312\274\300" +
    "\u0234\306\u0230\274\274\u028c\u0154\u028a\u014e\u0214\u0288" +
    "\u0286\274\274\350\274\u020a\274\u0284\u0208\u01d0\u0282" +
    "\274\u0296\u0280\304\u027e\u027c\274\302\u027a\274\u01fe" +
    "\u0278\274\u01d4\274\276\274\274\274\274\u01b2\274" +
    "\u0296\u01cc\u0180\u013e\u0276\274\u0176\u01ca\u0274\u0272\274" +
    "\300\276\274\274\274\u0136\u0108\u0100\u0270\u026e\u026c" +
    "\274\274\274\u02f8\000\000\000\000\002\006\000" +
    "\034\000\000\000\000\000\000\000\000\004\010" +
    "\032\154\152\156\160\000\014\066\140\012\016" +
    "\036\042\040\020\000\000\000\030\236\132\236" +
    "\000\000\000\000\134\000\000\000\130\136\164" +
    "\162\116\000\236\060\000\044\000\000\050\000" +
    "\000\054\000\000\000\000\000\122\000\000\000" +
    "\000\000\000\000\000\000\000\000\022\046\170" +
    "\166\000\024\052\174\026\056\000\214\222\216" +
    "\220\000\240\224\000\000\000\242\124\000\242" +
    "\000\000\000\000\000\120\142\202\000\000\000" +
    "\144\000\170\236\000\146\172\000\000\000\000" +
    "\000\000\000\070\076\204\150\176\176\000\000" +
    "\000\000\126\000\000\112\000\000\074\106\000" +
    "\064\000\000\226\000\100\000\102\072\000\062" +
    "\000\230\000\000\000\000\000\244\000\246\000" +
    "\000\232\236\236\236\110\104\000\000\000\000" +
    "\000\000\254\256\260\260\000\257\000\256\000" +
    "\224\000\220\000\170\000\151\000\237\047\234" +
    "\047\166\047\146\000\130\000\066\000\064\000" +
    "\047\000\045\000\005\000\002\011\152\047\150" +
    "\047\237\051\234\051\166\051\001\007\112\331" +
    "\237\053\234\053\166\053\237\055\234\055\166" +
    "\055\152\051\150\051\164\206\115\047\164\367" +
    "\152\053\150\053\111\047\152\055\150\055\103" +
    "\311\237\057\234\057\166\057\110\047\106\321" +
    "\115\051\205\212\107\047\164\200\111\051\115" +
    "\053\152\057\150\057\115\055\111\053\117\343" +
    "\110\051\111\055\265\206\104\047\107\051\110" +
    "\053\264\206\057\047\110\055\107\053\007\045" +
    "\115\057\107\055\075\247\055\047\111\057\104" +
    "\051\075\251\053\047\265\200\057\051\104\053" +
    "\110\057\264\200\104\055\057\053\107\313\055" +
    "\051\057\055\263\206\012\047\053\051\055\053" +
    "\246\206\010\047\055\055\053\053\251\u015d\104" +
    "\313\053\055\251\u015f\177\206\057\057\012\051" +
    "\175\206\070\157\263\200\010\051\012\053\055" +
    "\057\246\200\012\055\010\053\053\057\163\367" +
    "\010\055\161\210\161\u010b\177\200\177\u011d\070" +
    "\243\175\200\175\u011d\251\u0161\144\367\012\057" +
    "\245\206\145\113\145\115\010\057\145\117\145" +
    "\121\145\047\145\123\145\125\145\127\145\131" +
    "\145\133\125\174\145\135\072\247\145\137\145" +
    "\141\245\200\072\251\145\051\076\173\076\263" +
    "\145\143\145\311\145\053\241\206\041\157\145" +
    "\145\011\067\027\113\027\115\145\147\027\117" +
    "\027\121\027\047\027\123\027\125\027\127\027" +
    "\131\027\133\213\206\027\135\241\200\027\137" +
    "\027\141\140\355\003\013\027\051\073\165\073" +
    "\255\027\143\017\111\027\053\252\252\244\u0153" +
    "\027\145\140\271\213\200\232\250\027\147\140" +
    "\357\227\271\140\275\140\277\140\251\227\273" +
    "\212\271\227\275\227\277\207\206\212\273\154" +
    "\271\212\275\212\277\200\206\154\273\101\271" +
    "\154\275\154\277\227\301\101\273\056\225\101" +
    "\275\101\277\212\301\052\207\207\200\006\017" +
    "\171\206\154\301\167\222\200\200\157\114\153" +
    "\206\101\301\006\021\006\023\006\025\006\027" +
    "\006\031\006\033\006\035\006\037\141\234\006" +
    "\041\171\200\120\206\167\222\114\206\157\114" +
    "\153\200\113\206\102\206\100\206\065\206\062" +
    "\160\051\215\050\207\013\073\043\173\141\234" +
    "\013\075\013\077\120\200\042\165\114\200\016" +
    "\107\015\105\113\200\102\200\100\200\065\200" +
    "\062\160\014\103\000\003\270\u0177\267\u0175\266" +
    "\u0173\254\u0165\253\u0163\247\u015b\230\u0145\225\u0141" +
    "\222\u013d\221\u013b\217\u0137\214\u0133\211\u012d\202" +
    "\u0129\201\u0127\176\u0121\174\u011b\162\u010d\156\u0109" +
    "\155\u0107\143\365\133\353\116\341\216\u0135\243" +
    "\u0151\274\001\274\001\346\132\177\243\244\175" +
    "\122\112\252\222\001\206\126\001\151\164\147" +
    "\170\031\032\114\115\163\171\055\146\207\147" +
    "\246\031\032\174\031\032\311\311\311\064\303" +
    "\065\301\113\066\075\175\245\172\212\167\031" +
    "\032\031\032\016\267\277\064\071\065\063\102" +
    "\066\057\105\130\265\311\263\125\021\107\105" +
    "\006\160\146\200\261\257\122\031\032\255\122" +
    "\176\104\105\010\031\032\001\157\270\117\127" +
    "\031\032\210\000\132\211\117\020\032\003\021" +
    "\113\000\103\253\307\153\267\117\006\031\032" +
    "\013\121\040\047\152\275\251\002\031\032\247" +
    "\113\245\240\111\031\032\110\031\032\232\031" +
    "\032\305\230\237\034\266\117\161\031\032\234" +
    "\153\254\117\303\001\030\000\001\045\031\032" +
    "\024\001\226\253\117\003\221\204\247\117\230" +
    "\117\225\117\001\273\271\267\222\117\175\135" +
    "\111\221\117\217\117\214\117\201\117\162\117" +
    "\156\117\155\117\143\117\133\117\116\117\265" +
    "\101\264\101\263\101\213\101\120\101\102\101" +
    "\100\101\241\142\227\142\202\142\141\142\070" +
    "\071\073\074\076\077"
    };
  }

  /** Instance of action encapsulation class. */
  protected Action$ action_obj;

  /** Action encapsulation object initializer. */
  protected void init_actions()
    {
      action_obj = new Action$(this);
    }

  /** Invoke a user supplied parse action. */
  public java_cup.runtime.Symbol do_action(
    int                        act_num,
    java.util.ArrayList<java_cup.runtime.Symbol> stack)
    throws java.lang.Exception
  {
    /* call code in generated class */
    return action_obj.CUP$do_action(act_num, stack);
  }


  /** User initialization code. */
  public void user_init() throws java.lang.Exception
    {
 if (theory != null) { action_obj.theory = theory; action_obj.benchmark = new Benchmark(theory); } 
    }

  /** Scan to get the next Symbol. */
  public java_cup.runtime.Symbol scan()
    throws java.lang.Exception
    {
 return getScanner().next_token(); 
    }


	String filename;
	public void setFileName(String filename) {
		this.filename = filename;
	}
	
	public void report_error(String s, Object sym) {
		String location;
		if (sym instanceof MySymbolFactory.LineColumnSymbol) {
			MySymbolFactory.LineColumnSymbol bsym = (MySymbolFactory.LineColumnSymbol) sym;
			location = bsym.getLocation();
	    } else if ((sym instanceof Symbol) 
	    	       && ((Symbol)sym).sym == LexerSymbols.EOF) {
	    	location = "EOF";
	    } else
	        location = "UNKNOWN";
	    
		Logger.getRootLogger().error(filename+":"+location+": "+s);
	}

	public void report_error(String s) {	
		report_error(s, cur_token);
	}
	Theory theory = null;
	public void setTheory(Theory theory) {
		this.theory = theory;
	}


/** Cup generated class to encapsulate user supplied action code.*/
static class Action$ {


	Stack<TermVariable> varScopes = new Stack<TermVariable>();
	Stack<FormulaVariable> fvarScopes = new Stack<FormulaVariable>();
	Theory theory = new Theory();
	Benchmark benchmark = new Benchmark(theory);
	Sort errorSort = theory.createSort("*error*");
	
	public Sort lookupSort(Symbol sym, String name) {
		Sort s = theory.getSort(name);
		if (s == null)
			parser.report_error("Undeclared sort "+name, sym);
		return s;
	}

	public TermVariable findVar(String name) {
		ListIterator<TermVariable> it = varScopes.listIterator(varScopes.size());
		while (it.hasPrevious()) {
			TermVariable tv = it.previous();
			if (tv.getName().equals(name))
				return tv;
		}
		Logger.getRootLogger().error("Undeclared variable "+name);
		return theory.createTermVariable(name, errorSort);
	}
	
	public FormulaVariable findFvar(String name) {
		ListIterator<FormulaVariable> it = fvarScopes.listIterator(fvarScopes.size());
		while (it.hasPrevious()) {
			FormulaVariable fv = it.previous();
			if (fv.getName().equals(name))
				return fv;
		}
		Logger.getRootLogger().error("Undeclared form variable "+name);
		return theory.createFormulaVariable(name);
	}
	
	private Atom createAtomInternal(String pred, List<Term> params) {
		Term[] terms = params.toArray(new Term[params.size()]);
		Sort[] sorts = new Sort[terms.length];
		for (int i = 0; i < terms.length; i++) {
			sorts[i] = terms[i].getSort();
		}
		PredicateSymbol symb = theory.getPredicate(pred, sorts);
		if (symb == null)
			return null;
		return theory.atom(symb, terms);
	}
	
	private Term createFuncTermInternal(String f, List<Term> param) {
		Term[] terms = param.toArray(new Term[param.size()]);
		Sort[] sorts = new Sort[terms.length];
		for (int i = 0; i < sorts.length; i++) {
			sorts[i] = terms[i].getSort();
		}
		FunctionSymbol fsym = theory.getFunction(f, sorts);
		if (fsym == null) {
			if (terms.length == 0) {
			    return null;
			}
			/* Check if all sorts are equal and there is a binary function term */
			for (int i = 1; i < sorts.length; i++) {
				if (!sorts[i].equals(sorts[0])) {
					return null;
				}
			}
			/* Get binary function term */
			fsym = theory.getFunction(f, new Sort[] { sorts[0], sorts[0] });
			if (fsym == null || !fsym.getReturnSort().equals(sorts[0])) {
				return null;
			}
			/* Create nested application  (left-associative) */
			Term t = terms[0];
			for (int i = 1; i < terms.length; i++)
				t = theory.term(fsym, t, terms[i]);
			return t;
		}
		return theory.term(fsym, terms);
	}	
	
	public Term createFuncTerm(Symbol fsym, List<Term> param) {
		Term result = createFuncTermInternal((String) fsym.value, param);
		if (result == null) {
			parser.report_error("Undeclared function symbol "+fsym.value, fsym);
		}
		return result;
	}

	public Atom createAtom(Symbol psym, List<Term> params) {
		Atom result = createAtomInternal((String) psym.value, params);
		if (result == null) {
			parser.report_error("Undeclared predicate "+psym.value, psym);
		}
		return result;
	}
	
  	public SMTLibBase createTrigger(Symbol sym, List<Term> param) {
  		String id = (String)sym.value;
  		Term resultTerm = createFuncTermInternal(id, param);
  		if (resultTerm != null)
  			return resultTerm;
  		Atom resultAtom = createAtomInternal(id, param);
  		if (resultAtom == null) { 
  			parser.report_error("Undeclared symbol "+id, sym);
  		}
  		return resultAtom;
  	}

  private final Parser parser;

  /** Constructor */
  Action$(Parser parser) {
    this.parser = parser;
  }

  /** Method with the actual generated action code. */
  @SuppressWarnings({ "unused", "unchecked" })
  public final java_cup.runtime.Symbol CUP$do_action(
    int                        CUP$act_num,
    java.util.ArrayList<java_cup.runtime.Symbol> CUP$stack)
    throws java.lang.Exception
    {
      /* Stack size for peeking into the stack */
      int CUP$size = CUP$stack.size();

      /* select the action based on the action number */
      switch (CUP$act_num)
        {
          /*. . . . . . . . . . . . . . . . . . . .*/
          case 0: // $START ::= benchmark EOF 
            {
              Object RESULT = null;
              java_cup.runtime.Symbol start_val$ = CUP$stack.get(CUP$size - 2);
              Benchmark start_val = (Benchmark) start_val$.value;
RESULT = start_val;
              /* ACCEPT */
              parser.done_parsing();
              return parser.getSymbolFactory().newSymbol("$START", 0, start_val$, CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 1: // benchmark ::= LPAR BENCHMARK ID bench_attributeStar RPAR 
            {
              Benchmark RESULT = null;
              java_cup.runtime.Symbol name$ = CUP$stack.get(CUP$size - 3);
              String name = (String) name$.value;
 RESULT = benchmark; 
              return parser.getSymbolFactory().newSymbol("benchmark", 32, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 2: // bench_attributeStar ::= 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("bench_attributeStar", 30, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 3: // bench_attributeStar ::= bench_attributeStar bench_attribute 
            {
              return parser.getSymbolFactory().newSymbol("bench_attributeStar", 30, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 4: // bench_attribute ::= ATTR_LOGIC ID 
            {
              java_cup.runtime.Symbol logic$ = CUP$stack.get(CUP$size - 1);
              String logic = (String) logic$.value;
 theory.setLogic(logic); 
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), logic$);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 5: // bench_attribute ::= ATTR_ASSUMPTION formula 
            {
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 1);
              Formula f = (Formula) f$.value;
 benchmark.addFormula(f); 
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), f$);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 6: // bench_attribute ::= ATTR_FORMULA formula 
            {
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 1);
              Formula f = (Formula) f$.value;
 benchmark.addFormula(f); 
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), f$);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 7: // bench_attribute ::= ATTR_STATUS status 
            {
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 8: // bench_attribute ::= ATTR_EXTRASORTS LPAR extraSortPlus RPAR 
            {
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 9: // bench_attribute ::= ATTR_EXTRAFUNS LPAR extraFunPlus RPAR 
            {
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 10: // bench_attribute ::= ATTR_EXTRAPREDS LPAR extraPredPlus RPAR 
            {
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 11: // bench_attribute ::= ATTR_NOTES ATTR_STRING 
            {
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 benchmark.note(s); 
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), s$);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 12: // bench_attribute ::= ATTRIBUTE USERVAL 
            {
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 13: // bench_attribute ::= ATTRIBUTE 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("bench_attribute", 29, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 14: // status ::= SAT 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("status", 31, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 15: // status ::= UNSAT 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("status", 31, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 16: // status ::= UNKNOWN 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("status", 31, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 17: // extraSortPlus ::= extraSort 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("extraSortPlus", 23, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 18: // extraSortPlus ::= extraSortPlus extraSort 
            {
              return parser.getSymbolFactory().newSymbol("extraSortPlus", 23, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 19: // extraFunPlus ::= extraFun 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("extraFunPlus", 25, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 20: // extraFunPlus ::= extraFunPlus extraFun 
            {
              return parser.getSymbolFactory().newSymbol("extraFunPlus", 25, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 21: // extraPredPlus ::= extraPred 
            {
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("extraPredPlus", 27, CUP$sym, CUP$sym);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 22: // extraPredPlus ::= extraPredPlus extraPred 
            {
              return parser.getSymbolFactory().newSymbol("extraPredPlus", 27, CUP$stack.get(CUP$size - 2), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 23: // extraSort ::= ID 
            {
              java_cup.runtime.Symbol sort$ = CUP$stack.get(CUP$size - 1);
              String sort = (String) sort$.value;
 theory.createSort(sort); 
              return parser.getSymbolFactory().newSymbol("extraSort", 24, sort$, sort$);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 24: // extraFun ::= LPAR fun_symb sort_symbStar sort_symb annotationStar RPAR 
            {
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol rsort$ = CUP$stack.get(CUP$size - 3);
              Sort rsort = (Sort) rsort$.value;
              java_cup.runtime.Symbol psorts$ = CUP$stack.get(CUP$size - 4);
              List<Sort> psorts = (List<Sort>) psorts$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 5);
              String f = (String) f$.value;
 theory.createFunction(f, psorts.toArray(new Sort[psorts.size()]), rsort); 
              return parser.getSymbolFactory().newSymbol("extraFun", 26, CUP$stack.get(CUP$size - 6), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 25: // extraPred ::= LPAR fun_symb sort_symbStar annotationStar RPAR 
            {
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol psorts$ = CUP$stack.get(CUP$size - 3);
              List<Sort> psorts = (List<Sort>) psorts$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 4);
              String f = (String) f$.value;
 theory.createPredicate(f, psorts.toArray(new Sort[psorts.size()])); 
              return parser.getSymbolFactory().newSymbol("extraPred", 28, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1));
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 26: // formula ::= atom 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 1);
              Atom a = (Atom) a$.value;
 RESULT = a; 
              return parser.getSymbolFactory().newSymbol("formula", 7, a$, a$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 27: // formula ::= LPAR NOT formula annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 3);
              Formula f = (Formula) f$.value;
 RESULT = theory.not(f);
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 28: // formula ::= LPAR IF_THEN_ELSE formula formula formula annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol fe$ = CUP$stack.get(CUP$size - 3);
              Formula fe = (Formula) fe$.value;
              java_cup.runtime.Symbol ft$ = CUP$stack.get(CUP$size - 4);
              Formula ft = (Formula) ft$.value;
              java_cup.runtime.Symbol fc$ = CUP$stack.get(CUP$size - 5);
              Formula fc = (Formula) fc$.value;
 RESULT = theory.ifthenelse(fc, ft, fe);
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 7), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 29: // formula ::= LPAR IMPLIES formula formula annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol f2$ = CUP$stack.get(CUP$size - 3);
              Formula f2 = (Formula) f2$.value;
              java_cup.runtime.Symbol f1$ = CUP$stack.get(CUP$size - 4);
              Formula f1 = (Formula) f1$.value;
 RESULT = theory.implies(f1, f2);
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 6), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 30: // formula ::= LPAR connective formulaPlus annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol fl$ = CUP$stack.get(CUP$size - 3);
              List<Formula> fl = (List<Formula>) fl$.value;
              java_cup.runtime.Symbol c$ = CUP$stack.get(CUP$size - 4);
              Integer c = (Integer) c$.value;
 ListIterator<Formula> it = fl.listIterator(fl.size());
               RESULT = it.previous();
               while (it.hasPrevious()) {
                   if (c == ConnectedFormula.AND)
                       RESULT = theory.and(it.previous(), RESULT);
                   else if (c == ConnectedFormula.OR)
                       RESULT = theory.or(it.previous(), RESULT);
                   else if (c == ConnectedFormula.IFF)
                       RESULT = theory.iff(it.previous(), RESULT);
                   else if (c == ConnectedFormula.XOR)
                       RESULT = theory.xor(it.previous(), RESULT);
               }
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 31: // formula ::= LPAR EXISTS quantVarPlus formula patternStar annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 3);
              List<SMTLibBase[]> t = (List<SMTLibBase[]>) t$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 4);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol vl$ = CUP$stack.get(CUP$size - 5);
              List<TermVariable> vl = (List<TermVariable>) vl$.value;
 varScopes.setSize(varScopes.size() - vl.size());
               RESULT = theory.exists(vl.toArray(new TermVariable[vl.size()]), f,t.toArray(new SMTLibBase[t.size()][]));
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 7), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 32: // formula ::= LPAR FORALL quantVarPlus formula patternStar annotationStar RPAR 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 3);
              List<SMTLibBase[]> t = (List<SMTLibBase[]>) t$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 4);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol vl$ = CUP$stack.get(CUP$size - 5);
              List<TermVariable> vl = (List<TermVariable>) vl$.value;
 varScopes.setSize(varScopes.size() - vl.size());
               RESULT = theory.forall(vl.toArray(new TermVariable[vl.size()]), f,t.toArray(new SMTLibBase[t.size()][]));
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 7), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 33: // formula ::= LPAR LET LPAR VAR term RPAR NT$0 formula annotationStar RPAR 
            {
              Formula RESULT = (Formula) CUP$stack.get(CUP$size - 4).value;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 3);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol tv$ = CUP$stack.get(CUP$size - 6);
              Term tv = (Term) tv$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 7);
              String v = (String) v$.value;
 RESULT = theory.let(varScopes.pop(), tv, f);
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 10), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 34: // NT$0 ::= 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol tv$ = CUP$stack.get(CUP$size - 2);
              Term tv = (Term) tv$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 3);
              String v = (String) v$.value;
 varScopes.push(theory.createTermVariable(v, tv.getSort())); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("NT$0", 33, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 35: // formula ::= LPAR FLET LPAR FVAR formula RPAR NT$1 formula annotationStar RPAR 
            {
              Formula RESULT = (Formula) CUP$stack.get(CUP$size - 4).value;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 3);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol fv$ = CUP$stack.get(CUP$size - 6);
              Formula fv = (Formula) fv$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 7);
              String v = (String) v$.value;
 RESULT = theory.flet(fvarScopes.pop(), fv, f);
               RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("formula", 7, CUP$stack.get(CUP$size - 10), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 36: // NT$1 ::= 
            {
              Formula RESULT = null;
              java_cup.runtime.Symbol fv$ = CUP$stack.get(CUP$size - 2);
              Formula fv = (Formula) fv$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 3);
              String v = (String) v$.value;
 fvarScopes.push(theory.createFormulaVariable(v)); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("NT$1", 34, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 37: // formulaPlus ::= formulaStar formula 
            {
              List<Formula> RESULT = null;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 1);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<Formula> l = (List<Formula>) l$.value;
 RESULT = l; RESULT.add(f); 
              return parser.getSymbolFactory().newSymbol("formulaPlus", 5, l$, f$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 38: // formulaStar ::= 
            {
              List<Formula> RESULT = null;
 RESULT = new LinkedList<Formula>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("formulaStar", 6, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 39: // formulaStar ::= formulaStar formula 
            {
              List<Formula> RESULT = null;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 1);
              Formula f = (Formula) f$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<Formula> l = (List<Formula>) l$.value;
 RESULT = l; RESULT.add(f); 
              return parser.getSymbolFactory().newSymbol("formulaStar", 6, l$, f$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 40: // quantVarPlus ::= quantVar 
            {
              List<TermVariable> RESULT = null;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 1);
              TermVariable v = (TermVariable) v$.value;
 RESULT = new LinkedList<TermVariable>(); RESULT.add(v); varScopes.push(v);
              return parser.getSymbolFactory().newSymbol("quantVarPlus", 8, v$, v$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 41: // quantVarPlus ::= quantVarPlus quantVar 
            {
              List<TermVariable> RESULT = null;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 1);
              TermVariable v = (TermVariable) v$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<TermVariable> l = (List<TermVariable>) l$.value;
 RESULT = l; RESULT.add(v); varScopes.push(v);
              return parser.getSymbolFactory().newSymbol("quantVarPlus", 8, l$, v$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 42: // quantVar ::= LPAR VAR sort_symb RPAR 
            {
              TermVariable RESULT = null;
              java_cup.runtime.Symbol sort$ = CUP$stack.get(CUP$size - 2);
              Sort sort = (Sort) sort$.value;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 3);
              String v = (String) v$.value;
 RESULT = theory.createTermVariable(v, sort); 
              return parser.getSymbolFactory().newSymbol("quantVar", 9, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 43: // connective ::= OR 
            {
              Integer RESULT = null;
 RESULT = ConnectedFormula.OR; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("connective", 10, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 44: // connective ::= AND 
            {
              Integer RESULT = null;
 RESULT = ConnectedFormula.AND; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("connective", 10, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 45: // connective ::= IFF 
            {
              Integer RESULT = null;
 RESULT = ConnectedFormula.IFF; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("connective", 10, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 46: // connective ::= XOR 
            {
              Integer RESULT = null;
 RESULT = ConnectedFormula.XOR; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("connective", 10, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 47: // atom ::= prop_atom 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol pa$ = CUP$stack.get(CUP$size - 1);
              Atom pa = (Atom) pa$.value;
 RESULT = pa; 
              return parser.getSymbolFactory().newSymbol("atom", 11, pa$, pa$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 48: // atom ::= LPAR prop_atom annotationStar RPAR 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol pa$ = CUP$stack.get(CUP$size - 3);
              Atom pa = (Atom) pa$.value;
 RESULT = pa; pa.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("atom", 11, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 49: // atom ::= LPAR EQUALS termPlus annotationStar RPAR 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
 RESULT = theory.equals(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("atom", 11, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 50: // atom ::= LPAR DISTINCT termPlus annotationStar RPAR 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
 RESULT = theory.distinct(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("atom", 11, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 51: // atom ::= LPAR pred_symb termPlus annotationStar RPAR 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
              java_cup.runtime.Symbol pred$ = CUP$stack.get(CUP$size - 4);
              String pred = (String) pred$.value;
 RESULT = createAtom(pred$, tl); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("atom", 11, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 52: // prop_atom ::= TRUE 
            {
              Atom RESULT = null;
 RESULT = Atom.TRUE; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("prop_atom", 12, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 53: // prop_atom ::= FALSE 
            {
              Atom RESULT = null;
 RESULT = Atom.FALSE; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("prop_atom", 12, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 54: // prop_atom ::= FVAR 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 1);
              String f = (String) f$.value;
 RESULT = theory.atom(findFvar(f)); 
              return parser.getSymbolFactory().newSymbol("prop_atom", 12, f$, f$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 55: // prop_atom ::= ID 
            {
              Atom RESULT = null;
              java_cup.runtime.Symbol pred$ = CUP$stack.get(CUP$size - 1);
              String pred = (String) pred$.value;
 List<Term> args = Collections.emptyList();
	             RESULT = createAtom(pred$, args); 
              return parser.getSymbolFactory().newSymbol("prop_atom", 12, pred$, pred$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 56: // pred_symb ::= ARITH_SYMB 
            {
              String RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 RESULT = s; 
              return parser.getSymbolFactory().newSymbol("pred_symb", 15, s$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 57: // pred_symb ::= ID 
            {
              String RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 RESULT = s; 
              return parser.getSymbolFactory().newSymbol("pred_symb", 15, s$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 58: // fun_symb ::= ARITH_SYMB 
            {
              String RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 RESULT = s; 
              return parser.getSymbolFactory().newSymbol("fun_symb", 16, s$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 59: // fun_symb ::= ID 
            {
              String RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 RESULT = s; 
              return parser.getSymbolFactory().newSymbol("fun_symb", 16, s$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 60: // sort_symb ::= ID 
            {
              Sort RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              String s = (String) s$.value;
 RESULT = lookupSort(s$, s); 
              return parser.getSymbolFactory().newSymbol("sort_symb", 14, s$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 61: // sort_symbStar ::= 
            {
              List<Sort> RESULT = null;
 RESULT = new LinkedList<Sort>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("sort_symbStar", 13, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 62: // sort_symbStar ::= sort_symbStar sort_symb 
            {
              List<Sort> RESULT = null;
              java_cup.runtime.Symbol s$ = CUP$stack.get(CUP$size - 1);
              Sort s = (Sort) s$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<Sort> l = (List<Sort>) l$.value;
 RESULT = l; l.add(s); 
              return parser.getSymbolFactory().newSymbol("sort_symbStar", 13, l$, s$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 63: // annotationStar ::= 
            {
              HashMap<String,String> RESULT = null;
 RESULT = null; 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("annotationStar", 17, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 64: // annotationStar ::= annotationStar2 ATTRIBUTE 
            {
              HashMap<String,String> RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 1);
              String a = (String) a$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> l = (HashMap<String,String>) l$.value;
 RESULT = l; l.put(a, ""); 
              return parser.getSymbolFactory().newSymbol("annotationStar", 17, l$, a$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 65: // annotationStar ::= annotationStar2 ATTRIBUTE USERVAL 
            {
              HashMap<String,String> RESULT = null;
              java_cup.runtime.Symbol u$ = CUP$stack.get(CUP$size - 1);
              String u = (String) u$.value;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              String a = (String) a$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 3);
              HashMap<String,String> l = (HashMap<String,String>) l$.value;
 RESULT = l; l.put(a, u); 
              return parser.getSymbolFactory().newSymbol("annotationStar", 17, l$, u$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 66: // annotationStar2 ::= 
            {
              HashMap<String,String> RESULT = null;
 RESULT = new HashMap<String,String>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("annotationStar2", 18, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 67: // annotationStar2 ::= annotationStar2 ATTRIBUTE 
            {
              HashMap<String,String> RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 1);
              String a = (String) a$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> l = (HashMap<String,String>) l$.value;
 RESULT = l; l.put(a, ""); 
              return parser.getSymbolFactory().newSymbol("annotationStar2", 18, l$, a$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 68: // annotationStar2 ::= annotationStar2 ATTRIBUTE USERVAL 
            {
              HashMap<String,String> RESULT = null;
              java_cup.runtime.Symbol u$ = CUP$stack.get(CUP$size - 1);
              String u = (String) u$.value;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              String a = (String) a$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 3);
              HashMap<String,String> l = (HashMap<String,String>) l$.value;
 RESULT = l; l.put(a, u); 
              return parser.getSymbolFactory().newSymbol("annotationStar2", 18, l$, u$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 69: // base_term ::= VAR 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol v$ = CUP$stack.get(CUP$size - 1);
              String v = (String) v$.value;
 RESULT = theory.term(findVar(v)); 
              return parser.getSymbolFactory().newSymbol("base_term", 22, v$, v$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 70: // base_term ::= NUMERAL 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol n$ = CUP$stack.get(CUP$size - 1);
              String n = (String) n$.value;
 RESULT = theory.numeral(n); 
              return parser.getSymbolFactory().newSymbol("base_term", 22, n$, n$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 71: // base_term ::= RATIONAL 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol n$ = CUP$stack.get(CUP$size - 1);
              String n = (String) n$.value;
 RESULT = theory.rational(n); 
              return parser.getSymbolFactory().newSymbol("base_term", 22, n$, n$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 72: // base_term ::= ID 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol id$ = CUP$stack.get(CUP$size - 1);
              String id = (String) id$.value;
 List<Term> args = Collections.emptyList();
                RESULT = createFuncTerm(id$, args); 
              return parser.getSymbolFactory().newSymbol("base_term", 22, id$, id$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 73: // term ::= base_term 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 1);
              Term t = (Term) t$.value;
 RESULT = t; 
              return parser.getSymbolFactory().newSymbol("term", 21, t$, t$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 74: // term ::= LPAR base_term annotationStar RPAR 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 3);
              Term t = (Term) t$.value;
 RESULT = t; t.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("term", 21, CUP$stack.get(CUP$size - 4), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 75: // term ::= LPAR fun_symb termPlus annotationStar RPAR 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol param$ = CUP$stack.get(CUP$size - 3);
              List<Term> param = (List<Term>) param$.value;
              java_cup.runtime.Symbol f$ = CUP$stack.get(CUP$size - 4);
              String f = (String) f$.value;
RESULT = createFuncTerm(f$, param); RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("term", 21, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 76: // term ::= LPAR ITE formula term term annotationStar RPAR 
            {
              Term RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol el$ = CUP$stack.get(CUP$size - 3);
              Term el = (Term) el$.value;
              java_cup.runtime.Symbol th$ = CUP$stack.get(CUP$size - 4);
              Term th = (Term) th$.value;
              java_cup.runtime.Symbol cond$ = CUP$stack.get(CUP$size - 5);
              Formula cond = (Formula) cond$.value;
 RESULT = theory.ite(cond, th, el);
          RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("term", 21, CUP$stack.get(CUP$size - 7), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 77: // termPlus ::= termStar term 
            {
              List<Term> RESULT = null;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 1);
              Term t = (Term) t$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<Term> l = (List<Term>) l$.value;
 RESULT = l; l.add(t); 
              return parser.getSymbolFactory().newSymbol("termPlus", 19, l$, t$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 78: // termStar ::= 
            {
              List<Term> RESULT = null;
 RESULT = new LinkedList<Term>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("termStar", 20, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 79: // termStar ::= termStar term 
            {
              List<Term> RESULT = null;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 1);
              Term t = (Term) t$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<Term> l = (List<Term>) l$.value;
 RESULT = l; l.add(t); 
              return parser.getSymbolFactory().newSymbol("termStar", 20, l$, t$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 80: // patternStar ::= 
            {
              List<SMTLibBase[]> RESULT = null;
 RESULT = new LinkedList<SMTLibBase[]>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("patternStar", 1, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 81: // patternStar ::= patternStar ATTR_PATTERN LCPAR patPlus RCPAR 
            {
              List<SMTLibBase[]> RESULT = null;
              java_cup.runtime.Symbol t$ = CUP$stack.get(CUP$size - 2);
              List<SMTLibBase> t = (List<SMTLibBase>) t$.value;
              java_cup.runtime.Symbol p$ = CUP$stack.get(CUP$size - 5);
              List<SMTLibBase[]> p = (List<SMTLibBase[]>) p$.value;
 RESULT = p; p.add(t.toArray(new SMTLibBase[t.size()])); 
              return parser.getSymbolFactory().newSymbol("patternStar", 1, p$, CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 82: // patPlus ::= patStar pattern 
            {
              List<SMTLibBase> RESULT = null;
              java_cup.runtime.Symbol p$ = CUP$stack.get(CUP$size - 1);
              SMTLibBase p = (SMTLibBase) p$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<SMTLibBase> l = (List<SMTLibBase>) l$.value;
 RESULT = l; l.add(p); 
              return parser.getSymbolFactory().newSymbol("patPlus", 2, l$, p$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 83: // patStar ::= 
            {
              List<SMTLibBase> RESULT = null;
 RESULT = new LinkedList<SMTLibBase>(); 
              java_cup.runtime.Symbol CUP$sym = CUP$stack.get(CUP$size - 1);
              return parser.getSymbolFactory().newSymbol("patStar", 3, CUP$sym, CUP$sym, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 84: // patStar ::= patStar pattern 
            {
              List<SMTLibBase> RESULT = null;
              java_cup.runtime.Symbol p$ = CUP$stack.get(CUP$size - 1);
              SMTLibBase p = (SMTLibBase) p$.value;
              java_cup.runtime.Symbol l$ = CUP$stack.get(CUP$size - 2);
              List<SMTLibBase> l = (List<SMTLibBase>) l$.value;
 RESULT = l; l.add(p); 
              return parser.getSymbolFactory().newSymbol("patStar", 3, l$, p$, RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 85: // pattern ::= LPAR EQUALS termPlus annotationStar RPAR 
            {
              SMTLibBase RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
 RESULT = theory.equals(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("pattern", 4, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 86: // pattern ::= LPAR DISTINCT termPlus annotationStar RPAR 
            {
              SMTLibBase RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
 RESULT = theory.distinct(tl.toArray(new Term[tl.size()])); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("pattern", 4, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /*. . . . . . . . . . . . . . . . . . . .*/
          case 87: // pattern ::= LPAR ID termPlus annotationStar RPAR 
            {
              SMTLibBase RESULT = null;
              java_cup.runtime.Symbol a$ = CUP$stack.get(CUP$size - 2);
              HashMap<String,String> a = (HashMap<String,String>) a$.value;
              java_cup.runtime.Symbol tl$ = CUP$stack.get(CUP$size - 3);
              List<Term> tl = (List<Term>) tl$.value;
              java_cup.runtime.Symbol pred$ = CUP$stack.get(CUP$size - 4);
              String pred = (String) pred$.value;
 RESULT = createTrigger(pred$, tl); 
	     RESULT.setAnnotations(a); 
              return parser.getSymbolFactory().newSymbol("pattern", 4, CUP$stack.get(CUP$size - 5), CUP$stack.get(CUP$size - 1), RESULT);
            }

          /* . . . . . .*/
          default:
            throw new InternalError(
               "Invalid action number found in internal parse table");

        }
    }
}

}
