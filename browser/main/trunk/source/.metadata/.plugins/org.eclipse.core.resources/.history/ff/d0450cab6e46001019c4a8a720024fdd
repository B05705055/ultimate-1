package local.stalin.plugins.generator.lazyabstraction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import local.stalin.access.IUnmanagedObserver;
import local.stalin.access.WalkerOptions;
import local.stalin.core.api.StalinServices;
import local.stalin.model.IElement;
import local.stalin.model.INode;

import org.apache.log4j.Logger;
import org.eclipse.core.runtime.preferences.ConfigurationScope;
import org.eclipse.core.runtime.preferences.IEclipsePreferences;

import local.stalin.SMTInterface.SMTInterface;
import local.stalin.access.IUnmanagedObserver;
import local.stalin.access.WalkerOptions;
import local.stalin.boogie.cfgbuilder.CFGNode;
import local.stalin.boogie.cfgbuilder.CFGRootAnnotations;
import local.stalin.boogie.cfgreducer.Activator;
import local.stalin.boogie.cfgreducer.CFGEdge;
import local.stalin.boogie.cfgreducer.CFGExplicitNode;
import local.stalin.boogie.cfgreducer.PayloadModifier;
import local.stalin.boogie.cfgreducer.SMTEdgeAnnotations;
import local.stalin.boogie.cfgreducer.SMTNodeAnnotations;
//import local.stalin.boogie.cfgreducer.preferences.PreferenceValues;
import local.stalin.core.api.StalinServices;
import local.stalin.logic.ApplicationTerm;
import local.stalin.logic.Atom;
import local.stalin.logic.ConnectedFormula;
import local.stalin.logic.DistinctAtom;
import local.stalin.logic.EqualsAtom;
import local.stalin.logic.FletFormula;
import local.stalin.logic.Formula;
import local.stalin.logic.FormulaUnFleterer;
import local.stalin.logic.FormulaWalker;
import local.stalin.logic.FunctionSymbol;
import local.stalin.logic.ITEFormula;
import local.stalin.logic.ITETerm;
import local.stalin.logic.LetFormula;
import local.stalin.logic.NegatedFormula;
import local.stalin.logic.NumeralTerm;
import local.stalin.logic.PredicateAtom;
import local.stalin.logic.ProgramVariableTerm;
import local.stalin.logic.QuantifiedFormula;
import local.stalin.logic.RationalTerm;
import local.stalin.logic.Sort;
import local.stalin.logic.Term;
import local.stalin.logic.TermVariable;
import local.stalin.logic.Theory;
import local.stalin.logic.VariableAtom;
import local.stalin.logic.VariableTerm;
import local.stalin.model.IAnnotations;
import local.stalin.model.IEdge;
import local.stalin.model.IElement;
import local.stalin.model.INode;
import local.stalin.model.Payload;
import local.stalin.plugins.ResultNotifier;


/**
 * Auto-Generated Stub for the plug-in's Observer
 */
public class LazyAbstractionObserver implements IUnmanagedObserver {

	private static Logger s_Logger = StalinServices.getInstance().getLogger(Activator.PLUGIN_ID);
	
	private UnwindingNode m_graphroot;
	
	private HashMap<Term, String>		m_ConstantsToVariableName	= new HashMap<Term, String>();
	
	//introducing a Term for a non-SSA version of each program variable
	private HashMap<String,Term> m_VariableNameToTerm = new HashMap<String,Term>();
	
	private Theory m_theory;
	
	private ArrayList<UnwindingNode> m_openNodes;
	
	private UnwindingErrorLocation m_ErrorLocation;
	
	SMTInterface m_SMTInterface;
	
	boolean m_returnToUnwind;
	
	boolean returnImmediately = false;
	int noUnwind = 0;
	int noCover = 0;
	int noExpand = 0;
	int noClose = 0;
	int noDfs = 0;
	int noRefine = 0;
	
	@Override
	public boolean process(IElement node) {
		s_Logger.debug("entered process()");
		CFGExplicitNode root	= (CFGExplicitNode) node;
		m_theory 			= 
			((CFGRootAnnotations)root.getPayload().getAnnotations().get("CFGBuilder")).getTheory();
		m_graphroot		= new UnwindingNode(m_theory, Atom.TRUE);
		m_graphroot.setPayload(PayloadModifier.copyPayload(root.getPayload()));
		m_graphroot.setAsRoot();
	
		m_SMTInterface = new SMTInterface(m_theory, SMTInterface.SOLVER_GROUNDIFY);
		StalinServices.getInstance().putInToolchainStore("solver", m_SMTInterface);
		
		m_ErrorLocation = new UnwindingErrorLocation();
		
		for (INode n : root.getOutgoingNodes()) {

			UnwindingProcRoot procRoot = processProcedure((CFGExplicitNode) n);
			
			UnwindingEdge edge = new UnwindingEdge(m_theory, m_graphroot, procRoot);
			procRoot.addIncomingEdge(edge);
			m_graphroot.addOutgoingEdge(edge);
			
		}
		return false;
	}

	public UnwindingProcRoot processProcedure(CFGExplicitNode cfgProcNode) {
		UnwindingProcRoot procRoot = toUnwindingProcRoot(cfgProcNode);

		//expand 1 - convention: a procedure root node has exactly one child
		//and there's no assumption in the edge..
		CFGEdge cEdge = (CFGEdge) cfgProcNode.getOutgoingEdges().get(0);
		CFGExplicitNode cfgChild = (CFGExplicitNode) cEdge.getTarget();
		UnwindingNode unwChild = toUnwindingNode(cfgChild, procRoot);
		UnwindingEdge newEdge = 
			new UnwindingEdge(cfgProcNode.getTheory(),
					 procRoot, unwChild);
		unwChild.addIncomingEdge(newEdge);
		procRoot.addOutgoingEdge(newEdge);
			
		//execute the Lazy Abstraction Algorithm
		m_openNodes = new ArrayList<UnwindingNode>();
		m_openNodes.add(unwChild);
		paper_UNWIND();
		
//		int maxDepth = 20;
//		expandNode(procRoot, cfgProcNode, maxDepth);
		
		return procRoot;
	}
	
	int counter = 25;
	private void paper_UNWIND() {
//		s_Logger.debug("UNWIND has been called");
		noUnwind++;
		checkReturnImmediately();
		if(returnImmediately) return;
		
		while(!m_openNodes.isEmpty()) {
			//TODO: vorläufige abbruchbedingung
			counter--;
			if(counter < 0) return;
			m_returnToUnwind = false;
			ArrayList<UnwindingNode> openNodes_0 = 
				(ArrayList<UnwindingNode>) m_openNodes.clone();
			s_Logger.debug("UNWIND " + counter + ": open nodes " + openNodes_0);
			for(UnwindingNode openNode : openNodes_0) {
				//CLOSE() auf alle Vorgänger
				closeRec((UnwindingNode)(openNode.getIncomingEdges().get(0).getSource()));
				//DFS() auf openNode
				paper_DFS(openNode);
			}
		}
	}
	
	private void closeRec(UnwindingNode unwNode) {
		if(!(unwNode instanceof UnwindingProcRoot)) {
			paper_CLOSE(unwNode);
			UnwindingNode parent = (UnwindingNode)(unwNode.getIncomingEdges().get(0).getSource());
			if(!(parent instanceof UnwindingProcRoot)) {
				closeRec(parent);
			}
		}
	}


	
	private void paper_DFS(UnwindingNode v) {
//		s_Logger.debug("DFS has been called");
		noDfs++;
		if(returnImmediately) return;
		if(m_returnToUnwind) return; 
		
		paper_CLOSE(v);
		//if(v is Error Location) {
		paper_REFINE(v);
		closeRec(v);
		//}
		paper_EXPAND(v);
		
		for(IEdge edge : v.getOutgoingEdges()) {
			UnwindingEdge unwEdge = (UnwindingEdge) edge;
			paper_DFS((UnwindingNode) unwEdge.getTarget());
		}
	}
	

	
	private void paper_EXPAND(UnwindingNode v) {
//		s_Logger.debug("open Nodes before: " + m_openNodes);
//		s_Logger.debug("EXPAND has been called");
		noExpand++;
		if(returnImmediately) return;
		
		if(!v.isCovered() && v.isLeaf()) {
			CFGExplicitNode cfgNode = v.m_cfgLocation;//TODO: getter
			v.set_isLeaf(false);
			m_openNodes.remove(v);
			for(IEdge edge : cfgNode.getOutgoingEdges()) {
				CFGEdge cEdge = (CFGEdge) edge;
				CFGExplicitNode cfgChild = (CFGExplicitNode) cEdge.getTarget();
				UnwindingNode unwChild = toUnwindingNode(cfgChild, v.m_procRoot);
				
				UnwindingEdge newEdge = 
					new UnwindingEdge(cfgNode.getTheory(), cEdge.getSMTAnnotations(), v, unwChild);
				unwChild.addIncomingEdge(newEdge);
				v.addOutgoingEdge(newEdge);
				
				m_openNodes.add(unwChild);
				
				//update mapping of varNames to Terms (bisschen hässlich)
				for(String s : ((SMTNodeAnnotations) unwChild.getPayload()
						.getAnnotations().get("SMT")).getInVars().keySet()) {
					if(!m_VariableNameToTerm.containsKey(s)) {
						m_VariableNameToTerm.put(s, m_theory.term(m_theory.createTermVariable(s, m_theory.getSort(s))));
					}
				}
				for(String s : ((SMTEdgeAnnotations) newEdge.getPayload()
						.getAnnotations().get("SMT")).getInVars().keySet()) {
					if(!m_VariableNameToTerm.containsKey(s)) {
						m_VariableNameToTerm.put(s, m_theory.term(m_theory.createTermVariable(s, m_theory.getSort(s))));
					}
				}
				for(String s : ((SMTEdgeAnnotations) newEdge.getPayload()
						.getAnnotations().get("SMT")).getOutVars().keySet()) {
					if(!m_VariableNameToTerm.containsKey(s)) {
						m_VariableNameToTerm.put(s, m_theory.term(m_theory.createTermVariable(s, m_theory.getSort(s))));
					}
				}
				
			}
		}
		
		s_Logger.debug("open Nodes after: " + m_openNodes);
	}

	private void paper_REFINE(UnwindingNode v) {
//		s_Logger.debug("REFINE has been called");
		noRefine++;
		if(returnImmediately) return;
		//v is error loc. and not yet annotated false 
		//- the "false"-thing should be handled by openNodes
		if((v instanceof UnwindingErrorLocation) 
				&& (!v.getSMTAnnotations().getAssertion().equals(Atom.FALSE))) {
			ArrayList<IElement> path = getPath(v, new ArrayList<IElement>());
			Formula[] formulas = getFormulas(path);
			//generiere refutation/Interpolantensequenz für path
			//wenn sie existiert: 
			//wenn sie nicht existiert: unsafe

			try {
				Formula[] interpolants = m_SMTInterface.computeInterpolants(formulas, null);
				
				// update node annotations with the new interpolants
				// nur verstärken, wenn nicht eh schon impliziert
				// bei Verstärkung: davon gecovertes uncovern
				s_Logger.debug("REFINE: generated sequence of interpolants");
				for(int i = 0; i < interpolants.length; i++) {//Rundung checken
					SMTNodeAnnotations annotation = 
						(SMTNodeAnnotations) path.get(i*2+4).getPayload().getAnnotations().get("SMT");//rechnung stimmt immer?
					Formula oldFormula = annotation.getAssertion();//paper -> psi(v_i)
					
					if(m_SMTInterface.checkSatisfiabilitySmtlib(m_theory.implies(
							oldFormula, interpolants[i])) != 1) {
						Formula newFormula = m_theory.and(oldFormula, interpolants[i]);
						annotation.setAssertion(newFormula);	
						
						for(UnwindingNode w : v.get_coveredNodes()) {
							w.set_coveringNode(null);
							w.setCovered(false);
						}
						v.set_coveredNodes(null);
					}
				}
				
				m_openNodes.remove(v);
	
			} catch (RuntimeException ex) {
				s_Logger.fatal("--------- P R O G R A M   U N S A F E ---------");
			}
			//sh. ELG process() , SafetyCheckerObs
			//SSA: bei loops m_theory.let(..) invars, outvars, via Hashmap in Annot..
			//mapping per let in Formeln einbauen
			//invars, die keine Outvar haben: als Konstante, sh. auch SCObs -> getFormulas
			//z3: in preferences von stmIF pfad setzen
			//SafetyChecker: dumpFormula -> in Datei - z3 arbeitet darauf
			//nur sat: m_SMTIF.checkSatisfiabilitySmtlib(form)
			//covering: CFGEdge: checkSat/Val - baut die Formeln richtig um - assum true
		}
	}

//	private ArrayList<Formula> getPath(UnwindingNode v, ArrayList<Formula> path) {
//		if(!(v instanceof UnwindingProcRoot)) {
//			path.add(((SMTNodeAnnotations)v.getPayload().getAnnotations().get("SMT")).getAssertion());
//			path.add(((SMTEdgeAnnotations)v.getIncomingEdges().get(0).getPayload().getAnnotations().get("SMT")).getAssumption());
//			return getPath((UnwindingNode)v.getIncomingNodes().get(0), path);	
//		}
//		else {
//			return path;
//		}
//	}
	
	private ArrayList<IElement> getPath(UnwindingNode v, ArrayList<IElement> path) {
		if(!(v instanceof UnwindingProcRoot)) {
			path.add(v);
			path.add(v.getIncomingEdges().get(0));
			return getPath((UnwindingNode)v.getIncomingNodes().get(0), path);	
		}
		else {
			//sieht so aus, als wollte getformulas den pfad bis ganz oben(jetzt nicht mehr..), außerdem in 
			//umgekehrter Reihenfolge: von der Wurzel zum Blatt
			path.add(v);
//			path.add(v.getIncomingEdges().get(0));
//			path.add(v.getIncomingEdges().get(0).getSource());
			Collections.reverse(path);
			return path;
		}
	}

	private void paper_CLOSE(UnwindingNode v) {
//		s_Logger.debug("CLOSE has been called");
		noClose++;
		if(returnImmediately) return;
		//TODO: geht das effizienter?
		ArrayList<UnwindingNode> predecessors = new ArrayList<UnwindingNode>(
				v.m_procRoot.getPreorder().subList(0,
					v.m_procRoot.getPreorder().indexOf(v))); 
		
		for(UnwindingNode pred : predecessors) {
			if(pred.m_cfgLocation.equals(v.m_cfgLocation)) {
				paper_COVER(v, pred);
			}
		}
	}

//	/*
//	 * helper for retrieving all ancestors
//	 */
//	private ArrayList<UnwindingNode> collectAncestors(
//			UnwindingNode unwNode, ArrayList<UnwindingNode> collected) {
//		UnwindingNode parent = (UnwindingNode)(unwNode.getIncomingEdges().get(0).getSource());
//		if(parent.isProcRoot()) {
//			return collected;
//		}
//		else {
//			collected.add(parent);
//			return collected;
//		}
//			
//	}
	
//	private void expandNode(UnwindingNode node, CFGExplicitNode cfgNode, int maxDepth) {
//		if(maxDepth > 0) {
//			for(IEdge edge : cfgNode.getOutgoingEdges()) {
//				CFGEdge cEdge = (CFGEdge) edge;
//				CFGExplicitNode cfgChild = (CFGExplicitNode) cEdge.getTarget();
//				UnwindingNode unwChild = toUnwindingNode(cfgChild);
//				
//				UnwindingEdge newEdge = 
//					new UnwindingEdge(cfgNode.getTheory(), cEdge.getAssumption(), node, unwChild);
//				unwChild.addIncomingEdge(newEdge);
//				node.addOutgoingEdge(newEdge);
//				
//				expandNode(unwChild, cfgChild, maxDepth -1);
//			}
//		}
//	} 

	private void paper_COVER(UnwindingNode v, UnwindingNode w) {//w covert v ("v->w?")
//		s_Logger.debug("COVER has been called" + v + w);
		noCover++;
		if(returnImmediately) return;
		//ev nicht alle checks nötig..
		if((!v.isCovered()) 
				&& v.m_cfgLocation.equals(w.m_cfgLocation) 
				&& v.m_procRoot.getPreorder().indexOf(v) > v.m_procRoot.getPreorder().indexOf(w)) //> oder < ?? - wieso?
		{
			s_Logger.debug("COVER " + v + "->" + w + ": checking " + v.getSMTAnnotations().getAssertion() + " =>? " + w.getSMTAnnotations().getAssertion());	
			if(1 != m_SMTInterface.checkSatisfiabilitySmtlib(m_theory.not(m_theory.implies(
							transformFormula(v.getSMTAnnotations().getAssertion()), 
							transformFormula(w.getSMTAnnotations().getAssertion()))))) { 
				s_Logger.debug("implication valid -> covering..");
				v.set_coveringNode(w);
				w.get_coveredNodes().add(v);
				
				v.setCovered(true);
				m_openNodes.remove(v);
				
				if(v.getOutgoingNodes() != null)
					coverRec(v.getOutgoingNodes());
			}
		}
	}

	/*
	 * transform an assertion coming from a set of interpolants (what's in the nodes in lazy abstraction)
	 * in such a way that all its Termvariables are replaced by their nonSSA-counterparts
	 */
	private Formula transformFormula(Formula assertion) {
		if(assertion instanceof Atom) {
			if(assertion instanceof DistinctAtom) {
				Term[] newTerms = transformTerms(((DistinctAtom)assertion).getTerms());
				return m_theory.equals(newTerms);
			}
			else if(assertion instanceof EqualsAtom) {
				Term[] newTerms = transformTerms(((EqualsAtom)assertion).getTerms());
				return m_theory.equals(newTerms);
			}
			else if(assertion instanceof PredicateAtom) {
				Term[] newTerms = transformTerms(((PredicateAtom)assertion).getParameters());
				return m_theory.atom(((PredicateAtom)assertion).getPredicate(), newTerms);
			}
			else if(assertion instanceof VariableAtom) {
				return assertion;
			}
		}
		else if(assertion instanceof ConnectedFormula) {
			Formula lhs = transformFormula(((ConnectedFormula)assertion).getLhs());
			Formula rhs = transformFormula(((ConnectedFormula)assertion).getRhs());
			
			switch(((ConnectedFormula)assertion).getConnector()) {
			case 0:
				return m_theory.or(lhs, rhs);
			case 1:
				return m_theory.and(lhs, rhs);
			case 2:
				return m_theory.implies(lhs, rhs);
			case 3:
				return m_theory.iff(lhs, rhs);
			case 4:
				return m_theory.xor(lhs, rhs);
			case 5:
				return m_theory.oeq(lhs, rhs);					
			}
			
		}
		else if(assertion instanceof FletFormula) {
			return m_theory.flet(
					((FletFormula)assertion).getVariable(),//um FormulaVariables muss ich mich wohl nicht kümmern.. wohl ..
					transformFormula(((FletFormula)assertion).getValue()), 
					transformFormula(((FletFormula)assertion).getSubFormula()));
		}
		else if(assertion instanceof ITEFormula) {
			Formula cond = transformFormula(((ITEFormula)assertion).getCondition());
			Formula trueCase = transformFormula(((ITEFormula)assertion).getTrueCase());
			Formula falseCase = transformFormula(((ITEFormula)assertion).getFalseCase());
			return m_theory.ifthenelse(cond, trueCase, falseCase);
		}
		else if(assertion instanceof LetFormula) {
			Term varTerm = m_VariableNameToTerm.get(
					m_ConstantsToVariableName.get(
					((LetFormula)assertion).getVariable().getName()));
			TermVariable var = ((VariableTerm)varTerm).getVariable();
			
			Term[] valArray = new Term[1];
			Term val = ((LetFormula)assertion).getValue();
			valArray[0] = val;
			val = transformTerms(valArray)[0];
			
			Formula form = transformFormula(((LetFormula)assertion).getSubFormula());
			
			return m_theory.let(var, val, form);
		}
		else if(assertion instanceof NegatedFormula) {
			return m_theory.not(transformFormula(((NegatedFormula)assertion).getSubFormula()));
		}
		else if(assertion instanceof QuantifiedFormula) {
			switch(((QuantifiedFormula)assertion).getQuantifier()){
			case 0:
				return m_theory.exists(
						((QuantifiedFormula)assertion).getVariables(), ((QuantifiedFormula)assertion).getSubformula());
			case 1: 
				return m_theory.forall(
						((QuantifiedFormula)assertion).getVariables(), ((QuantifiedFormula)assertion).getSubformula());
			}
			//Achtung - keine Rekursion hier TODO: vermutlich müssen die quantifizierten Variablen 
			//bei der Transformation ausgespart werden
		}
		return null;
	}

	/*
	 * helper for transformAssertions - doing the same thing for terms
	 */
	private Term[] transformTerms(Term[] terms) {
		ArrayList<Term> toReturn = new ArrayList<Term>();
		
		if(terms instanceof ApplicationTerm[]) {
			ApplicationTerm[] terms1 = (ApplicationTerm[]) terms;
			for(ApplicationTerm t : terms1) {
				toReturn.add(m_theory.term(t.getFunction(), transformTerms(t.getParameters())));
			}
			return (Term[]) toReturn.toArray();
		}
		else if(terms instanceof ITETerm[]) {
			ITETerm[] terms1 = (ITETerm[]) terms;
			for(ITETerm t : terms1) {
				
				Term[] trueCase = new Term[1];
				trueCase[0] = t.getTrueCase();
				trueCase = transformTerms(trueCase);
				
				Term[] falseCase = new Term[1];
				falseCase[0] = t.getFalseCase();
				falseCase = transformTerms(falseCase);
				
				toReturn.add(m_theory.ite(transformFormula(t.getCondition()),
						trueCase[0], falseCase[0]));
			}
			return (Term[]) toReturn.toArray();
		}
		else if(terms instanceof NumeralTerm[]) {
			NumeralTerm[] terms1 = (NumeralTerm[]) terms;
			for(NumeralTerm t : terms1) {
				toReturn.add(t);
			}
		}
		else if(terms instanceof ProgramVariableTerm[]) {
			ProgramVariableTerm[] terms1 = (ProgramVariableTerm[]) terms;
			for(ProgramVariableTerm t : terms1) { //TODO: etwas spekulativ - was sind PVTs genau?
				toReturn.add(m_VariableNameToTerm.get(m_ConstantsToVariableName.get(
						t.toString().substring(0, t.toString().indexOf(" :")))));
			}
		}
		else if(terms instanceof RationalTerm[]) {
			RationalTerm[] terms1 = (RationalTerm[]) terms;
			for(RationalTerm t : terms1) {
				toReturn.add(t);//wie's aussieht stecken da keine Variablen drin
			}
		}
		else if(terms instanceof VariableTerm[]) {
			VariableTerm[] terms1 = (VariableTerm[]) terms;
			for(VariableTerm t : terms1) { //hier passiert's
				toReturn.add(m_VariableNameToTerm.get
						(m_ConstantsToVariableName.get(t.getVariable().getName())));
			}
		}
		return null;
	}

	/*
	 * for each given element recursively (going down) remove all covering edges connected to it
	 * and mark it as covered (by a node above of it by convention..)
	 */
	private void coverRec(List<INode> outgoingNodes) {
		for(INode iNode : outgoingNodes) {
			UnwindingNode unwNode = (UnwindingNode) iNode;
			
			unwNode.setCovered(true);
			m_openNodes.remove(unwNode);
			
			if(unwNode.get_coveringNode() != null) {
				unwNode.get_coveringNode().get_coveredNodes().remove(unwNode);
			}
			for(UnwindingNode un : unwNode.get_coveredNodes()) {
				un.set_coveringNode(null);
			}
			unwNode.get_coveredNodes().clear();
			unwNode.set_coveringNode(null);
			
			coverRec(unwNode.getOutgoingNodes());
		}
	}

	/*
	 * make an UnwindingNode out of a CFGNode - if there are assertions other than True
	 * then make an edge to the Error Location and move them there 
	 */
	private UnwindingNode toUnwindingNode(CFGExplicitNode oldNode, UnwindingProcRoot procRoot) {
		UnwindingNode newNode = new UnwindingNode(procRoot, oldNode);
		Payload newPayload = PayloadModifier.copyPayload(oldNode.getPayload());
		Formula assertion = ((SMTNodeAnnotations)newPayload.getAnnotations().get("SMT")).getAssertion();
		
		if(!(assertion.equals(Atom.TRUE))) {
			//replace assertion with Atom.True in the Node
			HashMap<String,IAnnotations> newAnnots = newPayload.getAnnotations();
			SMTNodeAnnotations newA = new SMTNodeAnnotations();
			newA.setAssertion(Atom.TRUE);
			newAnnots.put("SMT", newA);
			newPayload.setAnnotations(newAnnots); //unnötig/Quatsch?? wg ref?
			
			//add an edge with the assertion pointing to the error location
//			UnwindingEdge errorEdge = new UnwindingEdge(m_theory, assertion, newNode, m_ErrorLocation);
//			newNode.addOutgoingEdge(errorEdge);
//			m_ErrorLocation.addIncomingEdge(errorEdge);
			//version for improved graph readability: one error location each
			UnwindingErrorLocation el = new UnwindingErrorLocation(procRoot, oldNode);
			UnwindingEdge errorEdge = new UnwindingEdge(m_theory, oldNode.getSMTAnnotations(), newNode, el, true);
			newNode.addOutgoingEdge(errorEdge);
			el.addIncomingEdge(errorEdge);
			el.set_isLeaf(true);
			newNode.set_isLeaf(true);
			//always do refinement on error locations first, thus insert them an the 
			//beginning of m_openNodes
			m_openNodes.add(0, el);//TODO: Effizienz -> ev was anderes als ArrayList verwenden
			//if a new Error location has been discovered we have to return to UNWIND with the new list
			//otherwise it will never find any error locations
			m_returnToUnwind = true;
		}
		newNode.setPayload(newPayload);		
		
		return newNode;
	}

	private UnwindingProcRoot toUnwindingProcRoot(CFGExplicitNode oldNode) {
		UnwindingProcRoot newNode = new UnwindingProcRoot();
		newNode.setPayload(PayloadModifier.copyPayload(oldNode.getPayload()));
		return newNode;
	}
	
	
	@Override
	public void finish() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public WalkerOptions getWalkerOptions() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean performedChanges() {
		// TODO Auto-generated method stub
		return false;
	}
	
	/**
	 * @return the root of the CFG.
	 */
	public INode getRoot(){
		s_Logger.debug("getRoot has been called");
		boolean doLA = true; //TODO: only for debugging
		if(doLA)
			return (INode) m_graphroot;
		else
			return null;
	}

	//taken from SafetyChecker:
	//returns an array of the formulas corresponding to the current shortest path
	@SuppressWarnings("unchecked")
	private Formula[] getFormulas(ArrayList<IElement> path){
		ArrayList<Formula> tmp_formulas = new ArrayList<Formula>();
		//get all global variables from procedure entry node
		//If node holds any old variables then...
		
		//path has self-loops and therefore must be separated in pairs of node and outgoing edge
		HashMap<String, Term> outConstants = new HashMap<String, Term>();
		
		UnwindingNode procEntry = (UnwindingNode)path.get(0);//alex: geändert
		HashMap<TermVariable, Term> global_variables = new HashMap<TermVariable, Term>();
		HashMap<String, TermVariable> old_vars = (HashMap<String, TermVariable>)procEntry.getSMTAnnotations().getAnnotationsAsMap().get("oldvars");
		if (old_vars != null) {
			for (TermVariable global_tv: old_vars.values()){
				global_variables.put(global_tv, makeConstant(global_tv));
			}
			//filling up out_constants
			for(String vname: old_vars.keySet()){
				outConstants.put(vname, global_variables.get(old_vars.get(vname)));
			}
		}
		/*iterates through shortest path from node to node until reaching last node with outgoing edge
		 * and collects formulas in array tmp_formulas;
		 * starts at the procedure node and not the root node*/
		for (int i = 2; i < path.size(); i+=2){
			Formula tmp_formula = get_partialFormula(i, path, outConstants);
			//Adds all global variables to the formula
			for (TermVariable global_tv: global_variables.keySet()){
				tmp_formula = m_theory.let(global_tv, global_variables.get(global_tv), tmp_formula);
			}
			tmp_formulas.add(tmp_formula);
		}
		//putting list in an array and return that array
		Formula[] formulas = new Formula[tmp_formulas.size()];
		return tmp_formulas.toArray(formulas);
	}
	
	//builds and returns the formula for a i'th node and its succeeding edge on the current path
	private Formula get_partialFormula(int i, ArrayList<IElement> path, HashMap<String, Term> outConstants){
		//will hold the resulting formula
		Formula formula = null;
		//will hold the out going variables of the edge if node is not end of path
		HashMap<String, TermVariable> outgoingVariablesOfEdge = null;
		HashSet<TermVariable> variablesOfEdge = null;
		
		UnwindingNode		node				= (UnwindingNode)path.get(i);
		SMTNodeAnnotations	smtNodeAnnotations	= node.getSMTAnnotations();
		UnwindingEdge 		edge 				= null;
		SMTEdgeAnnotations	smtEdgeAnnotations	= new SMTEdgeAnnotations();
		
		//getting the incoming variables of the node
		HashMap<String, TermVariable>	incomingVariablesOfNode	= smtNodeAnnotations.getInVars();
		HashSet<TermVariable> 			variablesOfNode 		= smtNodeAnnotations.getVars();
		HashSet<TermVariable>			newVariables			= new HashSet<TermVariable>();
		newVariables.addAll(variablesOfNode);
		//HashMap that store all let-statements of this node's variables that are mapped to a constant
		HashMap<Term, TermVariable> allLetStatementsOfNode		= new HashMap<Term, TermVariable>();
		HashMap<Term, TermVariable> allIncomingConstantsOfNode	= new HashMap<Term, TermVariable>();
		//getting the formula of the node(assertion)
		Formula assertion = (Formula)smtNodeAnnotations.getAssertion();
		
		//Check if node is end of path ...
		if (i < path.size()-1){
			//node is not the end of the path
			edge = (UnwindingEdge)path.get(i+1);
			smtEdgeAnnotations = edge.getSMTAnnotations();
			//getting the outgoing variables of the edge
			HashMap<String, TermVariable> incomingVariablesOfEdge = smtEdgeAnnotations.getInVars();
			outgoingVariablesOfEdge = smtEdgeAnnotations.getOutVars();
			variablesOfEdge = smtEdgeAnnotations.getVars();
			//add node and edge variables to n_vars
			newVariables.addAll(variablesOfEdge);
			//getting the formula of the edge(assumption)
			Formula assumption = smtEdgeAnnotations.getAssumption();
			//building new formula but yet without mapping of in- and outgoing variables
			formula = m_theory.and(assertion, assumption);
			for(String vname: incomingVariablesOfEdge.keySet()){
				//if a outgoing constant has been declared for this incoming variable of the node then ...
				if (!outConstants.keySet().contains(vname)){
					//s_Logger.debug("This incoming variable " + vname + ": " + incomingVariablesOfEdge.get(vname).toString() + " of the node " + m_ShortestPath.get(i) +
					//		" has not been declared anywhere on the path \n" + m_ShortestPath.toString());
					outConstants.put(vname, makeConstant(incomingVariablesOfEdge.get(vname)));
				}
				TermVariable in_var = incomingVariablesOfEdge.get(vname);
				Term const_Term = outConstants.get(vname);
				formula = m_theory.let(in_var, const_Term, formula);
				allLetStatementsOfNode.put(const_Term, in_var);
				newVariables.remove(in_var);
			}
		} else {
			//node is end of path
			formula = assertion;
		}
		//iterating through all incoming variables of the node/edge
		for(String vname: incomingVariablesOfNode.keySet()){
			//if a outgoing constant has been declared for this incoming variable of the node then ...
			if (!outConstants.keySet().contains(vname)){
				s_Logger.debug("This incoming variable " + vname + ": " + incomingVariablesOfNode.get(vname).toString() + " of the node " + path.get(i) +
						" has not been declared anywhere on the path \n" + path.toString());
				outConstants.put(vname, makeConstant(incomingVariablesOfNode.get(vname)));
			}
			TermVariable in_var = incomingVariablesOfNode.get(vname);
			Term const_Term = outConstants.get(vname);
			formula = m_theory.let(in_var, const_Term, formula);
			allIncomingConstantsOfNode.put(const_Term, in_var);
			allLetStatementsOfNode.put(const_Term, in_var);
			newVariables.remove(in_var);
		}
		//make new constants only if there exists an outgoing edge
		if (edge != null){
			//get the incoming variables of the edge
			HashMap<String, TermVariable> in_vars_edge = smtEdgeAnnotations.getInVars();
			//iterating through all outgoing variables of the edge in order to declare constants and add them to out_constants
			for (String vname: outgoingVariablesOfEdge.keySet()){
				//check if this outgoing variable has really been changed or not
				if (in_vars_edge.containsValue(outgoingVariablesOfEdge.get(vname))){
					//if variable is also incoming variable then skip it
					continue;
				}
				//create new constant term for variable
				Term const_Term = makeConstant(outgoingVariablesOfEdge.get(vname));
				//map new constant to variable name
				outConstants.put(vname, const_Term);
				//map out going variable to new constant
				TermVariable out_var = outgoingVariablesOfEdge.get(vname);
				formula = m_theory.let(out_var, const_Term, formula);
				allLetStatementsOfNode.put(const_Term, out_var);
				newVariables.remove(out_var);
			}
		}
		//Check all remaining variables of the node which are not in or out variables
		for (TermVariable var: newVariables){
			Term const_Term = makeConstant(var);
			formula = m_theory.let(var, const_Term, formula);
			allLetStatementsOfNode.put(const_Term, var);
		}
		SCNodeAnnotations scAnnotations = (SCNodeAnnotations)node.getPayload().getAnnotations().get("SC");
		if (scAnnotations == null){
			scAnnotations = new SCNodeAnnotations();
			node.getPayload().getAnnotations().put("SC", scAnnotations);
		}
		scAnnotations.m_constants = allLetStatementsOfNode;
		return formula;
	}

	/*returns new constant for variable or
	 * returns constant that has already been created for this variable before
	 */
	private Term makeConstant(TermVariable tv){
		//new name for constant variable
		String constName = tv.getName() + "_const";
		//need a list of sorts of the input parameters of the function
		Sort[] dummy_Sorts = {};
		/*faking constant by creating function without input parameters and getting function symbol of newly created fake constant or
		 * of old fake constant that has already been created before*/
		FunctionSymbol fsym = m_theory.getFunction(constName, dummy_Sorts);
		if (fsym == null)
			fsym = m_theory.createFunction(constName, dummy_Sorts, tv.getSort());
		//need list of terms for input parameters of function in order to create term out of it
		Term[] dummyTerms = {};
		//making constant term and returning it
		Term const_Term = m_theory.term(fsym, dummyTerms);
//		const_to_Variable.put(const_Term, tv);
		m_ConstantsToVariableName.put(const_Term, tv.getName());
		return const_Term;
	}
	private void checkReturnImmediately() {
		returnImmediately = (noExpand <= 1);
	}
}
