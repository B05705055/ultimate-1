package local.stalin.plugins.generator.lazyabstraction;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.TreeSet;
import java.util.Map.Entry;

import local.stalin.access.IUnmanagedObserver;
import local.stalin.access.WalkerOptions;
import local.stalin.core.api.StalinServices;
import local.stalin.model.IElement;
import local.stalin.model.INode;

import org.apache.log4j.Logger;
import org.eclipse.core.runtime.preferences.ConfigurationScope;
import org.eclipse.core.runtime.preferences.IEclipsePreferences;

import local.stalin.SMTInterface.SMTInterface;
import local.stalin.access.IUnmanagedObserver;
import local.stalin.access.WalkerOptions;
import local.stalin.boogie.cfgbuilder.CFGNode;
import local.stalin.boogie.cfgbuilder.CFGRootAnnotations;
import local.stalin.boogie.cfgreducer.Activator;
import local.stalin.boogie.cfgreducer.CFGEdge;
import local.stalin.boogie.cfgreducer.CFGExplicitNode;
import local.stalin.boogie.cfgreducer.PayloadModifier;
import local.stalin.boogie.cfgreducer.SMTEdgeAnnotations;
import local.stalin.boogie.cfgreducer.SMTNodeAnnotations;
//import local.stalin.boogie.cfgreducer.preferences.PreferenceValues;
import local.stalin.core.api.StalinServices;
import local.stalin.logic.ApplicationTerm;
import local.stalin.logic.Atom;
import local.stalin.logic.ConnectedFormula;
import local.stalin.logic.DistinctAtom;
import local.stalin.logic.EqualsAtom;
import local.stalin.logic.FletFormula;
import local.stalin.logic.Formula;
import local.stalin.logic.FormulaUnFleterer;
import local.stalin.logic.FormulaWalker;
import local.stalin.logic.FunctionSymbol;
import local.stalin.logic.ITEFormula;
import local.stalin.logic.ITETerm;
import local.stalin.logic.LetFormula;
import local.stalin.logic.NegatedFormula;
import local.stalin.logic.NumeralTerm;
import local.stalin.logic.PredicateAtom;
import local.stalin.logic.ProgramVariableTerm;
import local.stalin.logic.QuantifiedFormula;
import local.stalin.logic.RationalTerm;
import local.stalin.logic.Sort;
import local.stalin.logic.Term;
import local.stalin.logic.TermVariable;
import local.stalin.logic.Theory;
import local.stalin.logic.VariableAtom;
import local.stalin.logic.VariableTerm;
import local.stalin.model.IAnnotations;
import local.stalin.model.IEdge;
import local.stalin.model.IElement;
import local.stalin.model.INode;
import local.stalin.model.Payload;
import local.stalin.model.boogie.ast.Attribute;
import local.stalin.model.boogie.ast.Declaration;
import local.stalin.model.boogie.ast.Procedure;
import local.stalin.plugins.ResultNotifier;


/**
 * Auto-Generated Stub for the plug-in's Observer
 */
public class LazyAbstractionObserver implements IUnmanagedObserver {

	private static Logger s_Logger = StalinServices.getInstance().getLogger(Activator.PLUGIN_ID);
	private UnwindingNode m_graphroot;
	private HashMap<Term, String>		m_ConstantsToVariableName	= new HashMap<Term, String>();
	//introducing a Term for a non-SSA version of each program variable
	private HashMap<String,Term> m_VariableNameToTerm = new HashMap<String,Term>();
	private Theory m_theory;
	private TreeSet<UnwindingNode> m_openNodes;
//	private LinkedHashSet<UnwindingNode> m_openErrorLocations;
	CFGRootAnnotations m_crAnnotations;
	HashMap<String, Declaration> m_declarationsByProcName;
//	private UnwindingErrorLocation m_ErrorLocation;
	
	SMTInterface m_SMTInterface;
	
	boolean m_programIncorrect = false;
	
	boolean m_returnToUnwind;
	
//	boolean returnImmediately = false;
//	int noUnwind = 0;
//	int noCover = 0;
	int noExpand = 0;
//	int noClose = 0;
//	int noDfs = 0;
//	int noRefine = 0;
	
	@Override
	public boolean process(IElement node) {
		s_Logger.debug("entered process()");
		CFGExplicitNode root	= (CFGExplicitNode) node;
		m_theory 			= 
			((CFGRootAnnotations)root.getPayload().getAnnotations().get("CFGBuilder")).getTheory();
		m_graphroot		= new UnwindingNode(m_theory, Atom.TRUE);
		m_graphroot.setPayload(PayloadModifier.copyPayload(root.getPayload()));
		m_graphroot.setAsRoot();
	
		m_crAnnotations = 
			((CFGRootAnnotations) m_graphroot.getPayload().getAnnotations().get("CFGBuilder")); 
		m_declarationsByProcName = new HashMap<String, Declaration>();
		
		//put the Declarations into a dictionary such that the can be accessed by procedure name
		s_Logger.debug(" ------  the declarations in the CFGBuilder Annotation:");
		m_crAnnotations.getAnnotationsAsMap();
		for(Declaration d : m_crAnnotations.getDeclarations()) {
			s_Logger.debug(d);
			
			m_declarationsByProcName.put(d.getPayload().getName(), d);
		}
		
		
		m_SMTInterface = new SMTInterface(m_theory, SMTInterface.SOLVER_GROUNDIFY);
		StalinServices.getInstance().putInToolchainStore("solver", m_SMTInterface);
		
//		m_ErrorLocation = new UnwindingErrorLocation();
		
		for (INode n : root.getOutgoingNodes()) {

			UnwindingProcRoot procRoot = processProcedure((CFGExplicitNode) n);
			
			UnwindingEdge edge = new UnwindingEdge(m_theory, m_graphroot, procRoot);
			procRoot.addIncomingEdge(edge);
			m_graphroot.addOutgoingEdge(edge);
	
		}
		
		if(m_programIncorrect) {
			s_Logger.info(" ------------- P R O G R A M   U N S A F E ------------------- ");
			ResultNotifier.programIncorrect();
		}
		else {
			s_Logger.info(" ------------- P R O G R A M   S A F E ------------------- ");
			ResultNotifier.programCorrect();	
		}
		
		return false;
	}

	public UnwindingProcRoot processProcedure(CFGExplicitNode cfgProcNode) {

		UnwindingProcRoot procRoot = toUnwindingProcRoot(cfgProcNode);
		
		//provide the information about specifications and such for this specific procedure
		String procName = procRoot.getPayload().getName();
		
//		Procedure x = ((Procedure)crAnnot.getDeclarations().get(0));
		
		
		m_openNodes = new TreeSet<UnwindingNode>(new UNWComparator());
		
		//expand 1 - convention: a procedure root node has exactly one child
		//and there's no assumption in the edge..
		CFGEdge cEdge = (CFGEdge) cfgProcNode.getOutgoingEdges().get(0);
		CFGExplicitNode cfgChild = (CFGExplicitNode) cEdge.getTarget();
		UnwindingNode unwChild = toUnwindingNode(cfgChild, procRoot);
		UnwindingEdge newEdge = 
			new UnwindingEdge(cfgProcNode.getTheory(),
					 procRoot, unwChild);
		unwChild.addIncomingEdge(newEdge);
		procRoot.addOutgoingEdge(newEdge);
			
		//execute the Lazy Abstraction Algorithm
		
//		m_openErrorLocations = new LinkedHashSet<UnwindingNode>();
		m_openNodes.add(unwChild);
		paper_UNWIND();
		
//		int maxDepth = 20;
//		expandNode(procRoot, cfgProcNode, maxDepth);
		
		return procRoot;
	}
	
//	int counter = 100;
	private void paper_UNWIND() {
//		s_Logger.debug("UNWIND has been called");
//		if(returnImmediately) return;


		
		while(!m_openNodes.isEmpty()/* || !m_openErrorLocations.isEmpty()*/) {
			s_Logger.debug("UNWIND: loop started again with " + m_openNodes);
			//TODO: vorläufige abbruchbedingung
//			counter--;
//			if(abortCondition()) {
//				ResultNotifier.programUnknown("abortCondition() became true");
//				return;
//			}//TODO: zeitschranke richtig ein bauen
//			if(counter < 0) return;
			if(m_programIncorrect) return;
			m_returnToUnwind = false;
			
			TreeSet<UnwindingNode> openNodes_0 = 
				(TreeSet<UnwindingNode>) m_openNodes.clone();
			
//			s_Logger.debug("UNWIND "/* + counter */+ ": open nodes " + openNodes_0);
			for(UnwindingNode openNode : openNodes_0) {
				//CLOSE() auf alle Vorgänger
				closeRec((UnwindingNode)(openNode.getIncomingEdges().get(0).getSource()));
				//DFS() auf openNode
				paper_DFS(openNode);
			}
		}
	}
	
	private void closeRec(UnwindingNode unwNode) {
		if(!(unwNode instanceof UnwindingProcRoot)) {
			paper_CLOSE(unwNode);
			UnwindingNode parent = (UnwindingNode)(unwNode.getIncomingEdges().get(0).getSource());
			if(!(parent instanceof UnwindingProcRoot)) {
				closeRec(parent);
			}
		}
	}
	
	private void paper_DFS(UnwindingNode v) {
//		s_Logger.debug("DFS has been called");
//		if(returnImmediately) return;
		if(abortCondition()) return;
		if(m_returnToUnwind) return; 
		
		paper_CLOSE(v);
		if(v instanceof UnwindingErrorLocation) {
			paper_REFINE((UnwindingErrorLocation) v);
			closeRec(v);
		}
		paper_EXPAND(v);
		
		for(IEdge edge : v.getOutgoingEdges()) {
			UnwindingEdge unwEdge = (UnwindingEdge) edge;
			paper_DFS((UnwindingNode) unwEdge.getTarget());
		}
	}
	
	private void paper_EXPAND(UnwindingNode v) {
		s_Logger.debug("open Nodes before: " + m_openNodes);
//		s_Logger.debug("EXPAND has been called");
		noExpand++;
		if(abortCondition()) return;
		
		if(!v.isCovered() && v.isLeaf()) {
			CFGExplicitNode cfgNode = v.m_cfgLocation;//TODO: getter
			v.set_isLeaf(false);
			m_openNodes.remove(v);
			for(IEdge edge : cfgNode.getOutgoingEdges()) {
				CFGEdge cEdge = (CFGEdge) edge;
				CFGExplicitNode cfgChild = (CFGExplicitNode) cEdge.getTarget();
				UnwindingNode unwChild = toUnwindingNode(cfgChild, v.m_procRoot);
//				unwChild.set_isLeaf(true);//wohl redundant mit defaultwert
				
				UnwindingEdge newEdge = 
					new UnwindingEdge(cfgNode.getTheory(), cEdge.getSMTAnnotations(), v, unwChild);
				unwChild.addIncomingEdge(newEdge);
				v.addOutgoingEdge(newEdge);
				
				m_openNodes.add(unwChild);

				updateVarNamesToTermsMapping(unwChild, newEdge);

			}
		}
		
		s_Logger.debug("open Nodes after: " + m_openNodes);
	}

	private void updateVarNamesToTermsMapping(UnwindingNode unwChild,
			UnwindingEdge newEdge) {
		//update mapping of varNames to Terms 
		for(Entry<String, TermVariable> e : ((SMTNodeAnnotations) unwChild.getPayload()
				.getAnnotations().get("SMT")).getInVars().entrySet()) {
			if(!m_VariableNameToTerm.containsKey(e.getValue().getName())) {
				if(m_theory.getFunction(e.getKey(), new Sort[0]) == null){
					updateVariableToTermNewFunction(e);
				}
				else {
					m_VariableNameToTerm.put(e.getValue().getName(), m_theory.term(
							m_theory.getFunction(e.getKey(), new Sort[0])));
				}
			}
		}
		for(Entry<String, TermVariable> e : ((SMTEdgeAnnotations) newEdge.getPayload()
				.getAnnotations().get("SMT")).getInVars().entrySet()) {
			if(!m_VariableNameToTerm.containsKey(e.getValue().getName())) {
				if(m_theory.getFunction(e.getKey(), new Sort[0]) == null){
					updateVariableToTermNewFunction(e);
				}
				else {
					m_VariableNameToTerm.put(e.getValue().getName(), m_theory.term(
							m_theory.getFunction(e.getKey(), new Sort[0])));
				}
			}
		}
		for(Entry<String, TermVariable> e : ((SMTEdgeAnnotations) newEdge.getPayload().getAnnotations()
				.get("SMT")).getOutVars().entrySet()) {
			if(!m_VariableNameToTerm.containsKey(e.getValue().getName())) {
				if(m_theory.getFunction(e.getKey(), new Sort[0]) == null){
					updateVariableToTermNewFunction(e);
				}
				else {
					m_VariableNameToTerm.put(e.getValue().getName(), m_theory.term(
							m_theory.getFunction(e.getKey(), new Sort[0])));
				}
			}
		}
	}

	/*
	 * helper function making paper_EXPAND less redundant
	 */
	private void updateVariableToTermNewFunction(Entry<String, TermVariable> e) {
		m_VariableNameToTerm.put(e.getValue().getName(), m_theory.term(
				m_theory.createFunction(e.getKey(), new Sort[0], e.getValue().getSort())));	
		m_VariableNameToTerm.put(e.getKey(), m_theory.term( //reflexivität - wieso eigentlich?
				m_theory.getFunction(e.getKey(), new Sort[0])));
		m_ConstantsToVariableName.put(m_theory.term(m_theory.getFunction(e.getKey(), new Sort[0])), e.getKey());
	}

	private boolean abortCondition() {
		return false;//noExpand>6;
	}

	private void paper_REFINE(UnwindingErrorLocation v) {//check auf EL schon eingebaut
//		s_Logger.debug("REFINE has been called");
//		if(returnImmediately) return;
		//v is error loc. and not yet annotated false 
		//- the "false"-thing should be handled by openNodes
		if(/*(v instanceof UnwindingErrorLocation) 
				&&*/ (!v.getSMTAnnotations().getAssertion().equals(Atom.FALSE))) {
			ArrayList<IElement> path = getPath(v, new ArrayList<IElement>());
			Formula[] formulas = getFormulas(path);
			//generiere refutation/Interpolantensequenz für path
			//wenn sie existiert: 
			//wenn sie nicht existiert: unsafe
			
			Formula[] interpolants = m_SMTInterface.computeInterpolants(formulas, null);
				
			if(interpolants != null) {
				// update node annotations with the new interpolants
				// nur verstärken, wenn nicht eh schon impliziert (sonst wird immer geuncovert)
				// bei Verstärkung: davon gecovertes uncovern
				s_Logger.debug("REFINE: generated sequence of interpolants");
				for(int i = 0; i < interpolants.length; i++) {//Rundung checken
					UnwindingNode nodeOnPath = (UnwindingNode) path.get(i*2+2); //rechnung stimmt immer?
					SMTNodeAnnotations annotation = 
						(SMTNodeAnnotations) nodeOnPath.getPayload().getAnnotations().get("SMT");
					
					
					Formula oldFormula = transformFormula(annotation.getAssertion());//paper -> psi(v_i)
					Formula interpolant = transformFormula(interpolants[i]);
					
					s_Logger.debug("REFINE: checking if assertion is strengthend " 
							+ oldFormula + " =>? " + interpolant);
					if(m_SMTInterface.checkSatisfiabilitySmtlib(m_theory.not(m_theory.implies(
							oldFormula, interpolant))) == 1) 
					{
						s_Logger.debug("REFINE: strengthening assertion with " + interpolant);
						Formula newFormula = m_theory.and(oldFormula, interpolant);
						annotation.setAssertion(newFormula);	
						
						//nodeOnPath covert nichts mehr
						for(UnwindingNode w : nodeOnPath.get_coveredNodes()) {
							w.set_coveringNode(null);
							w.setCovered(false);
							if(w.isLeaf()) 
							{
								m_openNodes.add(w);
							}
						}
						nodeOnPath.get_coveredNodes().clear();
//						seine nachfolger auch nicht - dürften sie eh nicht, 
//						aber setCovered muss auf jeden Fall gesetztwerden
						uncoverRec(nodeOnPath.getOutgoingNodes());
					}
				}
				v.set_isLeaf(false);
				m_openNodes.remove(v);
	
			} 
			else {
				s_Logger.info("--------- P R O G R A M   U N S A F E ---------");
				String errorPath = new String();
				for(Formula f : formulas) {
					errorPath += f.toString() + "\n";
				}
				
				s_Logger.info("Satisfiable Error Path: \n" + errorPath);
				m_programIncorrect = true;
//				counter = 0; //TODO: richtige Abbruchbedingung/schöner
			}
			//sh. ELG process() , SafetyCheckerObs
			//SSA: bei loops m_theory.let(..) invars, outvars, via Hashmap in Annot..
			//mapping per let in Formeln einbauen
			//invars, die keine Outvar haben: als Konstante, sh. auch SCObs -> getFormulas
			//z3: in preferences von stmIF pfad setzen
			//SafetyChecker: dumpFormula -> in Datei - z3 arbeitet darauf
			//nur sat: m_SMTIF.checkSatisfiabilitySmtlib(form)
			//covering: CFGEdge: checkSat/Val - baut die Formeln richtig um - assum true
		}
	}

	private ArrayList<IElement> getPath(UnwindingNode v, ArrayList<IElement> path) {
		if(!(v instanceof UnwindingProcRoot)) {
			path.add(v);
			path.add(v.getIncomingEdges().get(0));
			return getPath((UnwindingNode)v.getIncomingNodes().get(0), path);	
		}
		else {
			//sieht so aus, als wollte getformulas den pfad bis ganz oben(jetzt nicht mehr..), außerdem in 
			//umgekehrter Reihenfolge: von der Wurzel zum Blatt
			path.add(v);
//			path.add(v.getIncomingEdges().get(0));
//			path.add(v.getIncomingEdges().get(0).getSource());
			Collections.reverse(path);//könnte man sich mit einer Deque/Queue sparen..
			return path;
		}
	}

	private void paper_CLOSE(UnwindingNode v) {
//		s_Logger.debug("CLOSE has been called");
//		if(returnImmediately) return;
		//TODO: geht das effizienter? ev +-1 beim index?
		ArrayList<UnwindingNode> predecessors = new ArrayList<UnwindingNode>(
				v.m_procRoot.getPreorder().subList(0,
					v.getIndexInPreorder())); 
		//TODO: ist hier im paper squarekleinergleich oder geschweiftesdreieckkleinergleich gemeint?
		for(UnwindingNode pred : predecessors) {
			if(pred.m_cfgLocation.equals(v.m_cfgLocation)) {
				paper_COVER(v, pred);
			}
		}
	}

	private void paper_COVER(UnwindingNode v, UnwindingNode w) {//w covert v ("v->w?")
//		s_Logger.debug("COVER has been called" + v + w);
//		if(returnImmediately) return;
		//ev nicht alle checks nötig..
		if((!v.isCovered()) 
				&& v.m_cfgLocation.equals(w.m_cfgLocation) 
				&& v.getIndexInPreorder() > w.getIndexInPreorder()) 
		{
			s_Logger.debug("COVER: " + v + "->" + w + ": checking " 
					+ v.getSMTAnnotations().getAssertion() + " =>? " + w.getSMTAnnotations().getAssertion());
			Formula assertionV = /*transformFormula(*/v.getSMTAnnotations().getAssertion();//transformed wird schon in REFINE
			Formula assertionW = /*transformFormula(*/w.getSMTAnnotations().getAssertion();//wenn die formeln angelegt werden
//			s_Logger.debug("transformed version: " + assertionV + " =>? " + assertionW);
			if(1 != m_SMTInterface.checkSatisfiabilitySmtlib(m_theory.not(m_theory.implies(
							assertionV, 
							assertionW)))) { 
				s_Logger.debug("COVER: implication valid -> covering..");
				v.set_coveringNode(w);
				w.get_coveredNodes().add(v);
				v.setCovered(true);
				m_openNodes.remove(v);
				
				coverRec(v.getOutgoingNodes());
			}
		}
	}

	/*
	 * transform an assertion coming from a set of interpolants (what's in the nodes in lazy abstraction)
	 * in such a way that all its Termvariables are replaced by their nonSSA-counterparts
	 */
	private Formula transformFormula(Formula assertion) {
		if(assertion instanceof Atom) {
			if(assertion instanceof DistinctAtom) {
				Term[] newTerms = transformTerms(((DistinctAtom)assertion).getTerms());
				return m_theory.equals(newTerms);
			}
			else if(assertion instanceof EqualsAtom) {
				Term[] newTerms = transformTerms(((EqualsAtom)assertion).getTerms());
				return m_theory.equals(newTerms);
			}
			else if(assertion instanceof PredicateAtom) {
				Term[] newTerms = transformTerms(((PredicateAtom)assertion).getParameters());
				return m_theory.atom(((PredicateAtom)assertion).getPredicate(), newTerms);
			}
			else if(assertion instanceof VariableAtom) {
				return assertion;
			}
			else {
				return assertion; //must be Atom.TRUE/FALSE then..
			}
		}
		else if(assertion instanceof ConnectedFormula) {
			Formula lhs = transformFormula(((ConnectedFormula)assertion).getLhs());
			Formula rhs = transformFormula(((ConnectedFormula)assertion).getRhs());
			
			switch(((ConnectedFormula)assertion).getConnector()) {
			case 0:
				return m_theory.or(lhs, rhs);
			case 1:
				return m_theory.and(lhs, rhs);
			case 2:
				return m_theory.implies(lhs, rhs);
			case 3:
				return m_theory.iff(lhs, rhs);
			case 4:
				return m_theory.xor(lhs, rhs);
			case 5:
				return m_theory.oeq(lhs, rhs);					
			}
			
		}
		else if(assertion instanceof FletFormula) {
			return m_theory.flet(
					((FletFormula)assertion).getVariable(),//um FormulaVariables muss ich mich wohl nicht kümmern.. wohl ..
					transformFormula(((FletFormula)assertion).getValue()), 
					transformFormula(((FletFormula)assertion).getSubFormula()));
		}
		else if(assertion instanceof ITEFormula) {
			Formula cond = transformFormula(((ITEFormula)assertion).getCondition());
			Formula trueCase = transformFormula(((ITEFormula)assertion).getTrueCase());
			Formula falseCase = transformFormula(((ITEFormula)assertion).getFalseCase());
			return m_theory.ifthenelse(cond, trueCase, falseCase);
		}
		else if(assertion instanceof LetFormula) {
			Term varTerm = m_VariableNameToTerm.get(
					m_ConstantsToVariableName.get(
					((LetFormula)assertion).getVariable().getName()));
			TermVariable var = ((VariableTerm)varTerm).getVariable();
			
			Term[] valArray = new Term[1];
			Term val = ((LetFormula)assertion).getValue();
			valArray[0] = val;
			val = transformTerms(valArray)[0];
			
			Formula form = transformFormula(((LetFormula)assertion).getSubFormula());
			
			return m_theory.let(var, val, form);
		}
		else if(assertion instanceof NegatedFormula) {
			return m_theory.not(transformFormula(((NegatedFormula)assertion).getSubFormula()));
		}
		else if(assertion instanceof QuantifiedFormula) {
			switch(((QuantifiedFormula)assertion).getQuantifier()){
			case 0:
				return m_theory.exists(
						((QuantifiedFormula)assertion).getVariables(), ((QuantifiedFormula)assertion).getSubformula());
			case 1: 
				return m_theory.forall(
						((QuantifiedFormula)assertion).getVariables(), ((QuantifiedFormula)assertion).getSubformula());
			}
			//Achtung - keine Rekursion hier TODO: vermutlich müssen die quantifizierten Variablen 
			//bei der Transformation ausgespart werden
		}
		return null;
	}

	private Term[] transformTerms(Term[] terms) {
		ArrayList<Term> toReturn = new ArrayList<Term>();
		for(Term t : terms) {
			toReturn.add(transformTerm(t));
		}
		return toReturn.toArray(terms);
	}
	
	
	/*
	 * helper for transformAssertions - doing the same thing for terms
	 */
	private Term transformTerm(Term term) {
//		ArrayList<Term> toReturn = new ArrayList<Term>();
		
		if(term instanceof ApplicationTerm) {
			ApplicationTerm term1 = (ApplicationTerm) term;
			if(term1.getParameters().length != 0) {
				return m_theory.term(term1.getFunction(), transformTerms(term1.getParameters()));
			}
			else {
				return m_VariableNameToTerm.get(m_ConstantsToVariableName.get(term1));
			}
			
		}
		else if(term instanceof ITETerm) {
			ITETerm term1 = (ITETerm) term;

			Term trueCase = transformTerm(term1.getTrueCase());
			Term falseCase = transformTerm(term1.getFalseCase());

			return m_theory.ite(transformFormula(term1.getCondition()),
					trueCase, falseCase);
		}
		else if(term instanceof NumeralTerm) {
//			NumeralTerm terms = (NumeralTerm) term;
			return term;
		}
		else if(term instanceof ProgramVariableTerm) {
			ProgramVariableTerm term1 = (ProgramVariableTerm) term;
			//TODO: etwas spekulativ - was sind PVTs genau?
			return m_VariableNameToTerm.get(m_ConstantsToVariableName.get(
						term1.toString().substring(0, term1.toString().indexOf(" :"))));
		}
		else if(term instanceof RationalTerm) {
//			RationalTerm terms1 = (RationalTerm) term;
			return term;//wie's aussieht stecken da keine Variablen drin
		}
		else if(term instanceof VariableTerm) {
			//ev quatsch/dürfte nicht vorkommen, da konstanten als 0-stellige Fkten modelliert sind
			VariableTerm term1 = (VariableTerm) term;
			return m_VariableNameToTerm.get
						(m_ConstantsToVariableName.get(term1.getVariable().getName()));
		}
		return null;
	}

	/*
	 * for each given element recursively (going down) remove all covering edges connected to it
	 * and mark it as covered (by a node above of it by convention..)
	 */
	private void coverRec(List<INode> outgoingNodes) {
		if(outgoingNodes == null) return;
		for(INode iNode : outgoingNodes) {
			UnwindingNode unwNode = (UnwindingNode) iNode;
			
			unwNode.setCovered(true);
			m_openNodes.remove(unwNode);
			
			if(unwNode.get_coveringNode() != null) {
				unwNode.get_coveringNode().get_coveredNodes().remove(unwNode);
			}
			for(UnwindingNode un : unwNode.get_coveredNodes()) {
				un.set_coveringNode(null);
				if(un.isLeaf()) {
					m_openNodes.add(un);
					uncoverRec(un.getOutgoingNodes());
				}
			}
			unwNode.get_coveredNodes().clear();
			unwNode.set_coveringNode(null);
			
			coverRec(unwNode.getOutgoingNodes());
		}
	}
	
	/*
	 * for each given element recursively (going down) set isCovered false and 
	 * clear the coveringNodes List 
	 */
	private void uncoverRec(List<INode> outgoingNodes) {
		if(outgoingNodes == null) return;
		for(INode iNode : outgoingNodes) {
			UnwindingNode unwNode = (UnwindingNode) iNode;
			
			unwNode.setCovered(false);
			if(unwNode.isLeaf()) {
				m_openNodes.add(unwNode);	
			}
						
			if(unwNode.get_coveringNode() != null) {
				unwNode.set_coveringNode(null);
			}
//			for(UnwindingNode un : unwNode.get_coveredNodes()) {
//				un.set_coveringNode(null);
//			}
//			unwNode.get_coveredNodes().clear();
//			unwNode.set_coveringNode(null);
			
			uncoverRec(unwNode.getOutgoingNodes());
		}
	}

	/*
	 * make an UnwindingNode out of a CFGNode - if there are assertions other than True
	 * then make an edge to the Error Location and move them there 
	 */
	private UnwindingNode toUnwindingNode(CFGExplicitNode oldNode, UnwindingProcRoot procRoot) {
		UnwindingNode newNode = new UnwindingNode(procRoot, oldNode);
		Payload newPayload = PayloadModifier.copyPayload(oldNode.getPayload());
		Formula assertion = ((SMTNodeAnnotations)newPayload.getAnnotations().get("SMT")).getAssertion();
		
		if(!(assertion.equals(Atom.TRUE))) {
			//replace assertion with Atom.True in the Node
			HashMap<String,IAnnotations> newAnnots = newPayload.getAnnotations();
			SMTNodeAnnotations newA = new SMTNodeAnnotations();
			newA.setAssertion(Atom.TRUE);
			newAnnots.put("SMT", newA);
			newPayload.setAnnotations(newAnnots); //unnötig/Quatsch?? wg ref?
			
			//add an edge with the assertion pointing to the error location
//			UnwindingEdge errorEdge = new UnwindingEdge(m_theory, assertion, newNode, m_ErrorLocation);
//			newNode.addOutgoingEdge(errorEdge);
//			m_ErrorLocation.addIncomingEdge(errorEdge);
			//version for improved graph readability: one error location each
			UnwindingErrorLocation el = new UnwindingErrorLocation(procRoot, oldNode);
			UnwindingEdge errorEdge = new UnwindingEdge(m_theory, oldNode.getSMTAnnotations(), newNode, el, true);
			newNode.addOutgoingEdge(errorEdge);
			el.addIncomingEdge(errorEdge);
			el.set_isLeaf(true);
			newNode.set_isLeaf(true);
			//always do refinement on error locations first, thus insert them an the 
			//beginning of m_openNodes
			m_openNodes.add(el);
			//if a new Error location has been discovered we have to return to UNWIND with the new list
			//otherwise it will never find any error locations
			m_returnToUnwind = true;
//			if(oldNode.getOutgoingEdges(). size() == 0) //-> wohl böse, da dann expand auf den knoten nichts mehr macht
//				newNode.set_isLeaf(false);
		}
		newNode.setPayload(newPayload);		
		//helpers for debugging
		String oldName = newNode.getPayload().getName();
		String sUID = newNode.getPayload().getID().toString();
		newNode.getPayload().setName(oldName.replace("$Stalin#", "")
				+ "-" + sUID.substring(0, sUID.length()/6));
		newNode.getPayload().getAnnotations().put("LA", new LAAnnotations(newNode));
		newNode.getPayload().getAnnotations().remove("SC");
		
		return newNode;
	}

	private UnwindingProcRoot toUnwindingProcRoot(CFGExplicitNode oldNode) {
		UnwindingProcRoot newNode = new UnwindingProcRoot();
		newNode.setPayload(PayloadModifier.copyPayload(oldNode.getPayload()));
		return newNode;
	}
	
	
	@Override
	public void finish() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public WalkerOptions getWalkerOptions() {
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void init() {
		// TODO Auto-generated method stub
		
	}

	@Override
	public boolean performedChanges() {
		// TODO Auto-generated method stub
		return false;
	}
	
	/**
	 * @return the root of the CFG.
	 */
	public INode getRoot(){
		s_Logger.debug("getRoot has been called");
		boolean doLA = true; //TODO: only for debugging -> viewing the cfg without changing the toolchain
		if(doLA)
			return (INode) m_graphroot;
		else
			return null;
	}

	private Formula[] getFormulas(ArrayList<IElement> path) {
		//container for the Formulas to be returned
		ArrayList<Formula> formulas = new ArrayList<Formula>();
		//we are not interested in the nodes: make a list of the edges only
		ArrayList<UnwindingEdge> edges = new ArrayList<UnwindingEdge>();
		for(int i = 1; i < path.size(); i+=2) {
			edges.add((UnwindingEdge) path.get(i));
		}
		
		HashMap<String, Term> availableVars = new HashMap<String,Term>();
//		HashSet<TermVariable> usedVars = new HashSet<TermVariable>(); //?

		//add the transformed formulas to the returned array
		for(UnwindingEdge edge : edges) {
//			Formula newFormula;
			Formula assumption = edge.getSMTAnnotations().getAssumption();
			
//			HashMap<TermVariable,TermVariable> letMapping = new HashMap<TermVariable,TermVariable>();
			
			HashSet<TermVariable> notInOutVars = 
				(HashSet<TermVariable>) edge.getSMTAnnotations().getVars().clone();
			
			for(Entry<String, TermVariable> entry : edge.getSMTAnnotations().getInVars().entrySet()) {
				notInOutVars.remove(entry.getValue());
				//wohin der wert von key zuletzt gespeichert wurde
				Term tvIn = availableVars.get(entry.getKey());
				if(tvIn == null) { //the variable is not initialised at that program point
					tvIn = makeConstant(entry.getValue());
				}
				//let entry.value = tvIn
				assumption = m_theory.let(entry.getValue(), tvIn, assumption);
				if(edge.getSMTAnnotations().getOutVars().containsValue(entry.getValue())) {
					availableVars.put(entry.getKey(), tvIn);
				}
			}
			
			for(Entry<String, TermVariable> entry : edge.getSMTAnnotations().getOutVars().entrySet()) {
				notInOutVars.remove(entry.getValue());
				if(!edge.getSMTAnnotations().getInVars().containsValue(entry.getValue())) {
					Term tOut = makeConstant(
							m_theory.createFreshTermVariable("", entry.getValue().getSort()), entry.getKey());
					assumption = m_theory.let(entry.getValue(), tOut, assumption);
					availableVars.put(entry.getKey(), tOut);
				}
			}
			
			for(TermVariable tv : notInOutVars) {
				Term con = makeConstant(tv);
				assumption = m_theory.let(tv, con, assumption);
			}
//			availableVars.putAll(edge.getSMTAnnotations().getOutVars());//noch frisch machen
			
			formulas.add(assumption);
		}
		formulas.add(Atom.TRUE); // ev am Abschluss nötig..?
		Formula[] fArray = new Formula[formulas.size()];
		return formulas.toArray(fArray);
	}
	
	//taken from SafetyChecker:
	//returns an array of the formulas corresponding to the current shortest path
	@SuppressWarnings("unchecked")
	private Formula[] getFormulasOld(ArrayList<IElement> path){
		ArrayList<Formula> tmp_formulas = new ArrayList<Formula>();
		//get all global variables from procedure entry node
		//If node holds any old variables then...
		
		//path has self-loops and therefore must be separated in pairs of node and outgoing edge
		HashMap<String, Term> outConstants = new HashMap<String, Term>();
		
		UnwindingNode procEntry = (UnwindingNode)path.get(0);//alex: geändert
		HashMap<TermVariable, Term> global_variables = new HashMap<TermVariable, Term>();
		HashMap<String, TermVariable> old_vars = (HashMap<String, TermVariable>)procEntry
							.getSMTAnnotations().getAnnotationsAsMap().get("oldvars");
		if (old_vars != null) {
			for (TermVariable global_tv: old_vars.values()){
				global_variables.put(global_tv, makeConstant(global_tv));
			}
			//filling up out_constants
			for(String vname: old_vars.keySet()){
				outConstants.put(vname, global_variables.get(old_vars.get(vname)));
			}
		}
		/*iterates through shortest path from node to node until reaching last node with outgoing edge
		 * and collects formulas in array tmp_formulas;
		 * starts at the procedure node and not the root node*/
		for (int i = 2; i < path.size(); i+=2){//2~>0 alex... wie bei procRoot..???
			Formula tmp_formula = get_partialFormula(i, path, outConstants);
			//Adds all global variables to the formula
			for (TermVariable global_tv: global_variables.keySet()){
				tmp_formula = m_theory.let(global_tv, global_variables.get(global_tv), tmp_formula);
			}
			tmp_formulas.add(tmp_formula);
		}
		//putting list in an array and return that array
		Formula[] formulas = new Formula[tmp_formulas.size()];
		return tmp_formulas.toArray(formulas);
	}
	
	//builds and returns the formula for a i'th node and its succeeding edge on the current path
	private Formula get_partialFormula(int i, ArrayList<IElement> path, HashMap<String, Term> outConstants){
		//will hold the resulting formula
		Formula formula = null;
		//will hold the out going variables of the edge if node is not end of path
		HashMap<String, TermVariable> outgoingVariablesOfEdge = null;
		HashSet<TermVariable> variablesOfEdge = null;
		
		UnwindingNode		node				= (UnwindingNode)path.get(i);
		SMTNodeAnnotations	smtNodeAnnotations	= node.getSMTAnnotations();
		UnwindingEdge 		edge 				= null;
		SMTEdgeAnnotations	smtEdgeAnnotations	= new SMTEdgeAnnotations();
		
		//getting the incoming variables of the node
		HashMap<String, TermVariable>	incomingVariablesOfNode	= smtNodeAnnotations.getInVars();
		HashSet<TermVariable> 			variablesOfNode 		= smtNodeAnnotations.getVars();
		HashSet<TermVariable>			newVariables			= new HashSet<TermVariable>();
		newVariables.addAll(variablesOfNode);
		//HashMap that store all let-statements of this node's variables that are mapped to a constant
		HashMap<Term, TermVariable> allLetStatementsOfNode		= new HashMap<Term, TermVariable>();
		HashMap<Term, TermVariable> allIncomingConstantsOfNode	= new HashMap<Term, TermVariable>();
		//getting the formula of the node(assertion)
//		Formula assertion = (Formula)smtNodeAnnotations.getAssertion();

		//Check if node is end of path ...
		if (i < path.size()-1){
			//node is not the end of the path
			edge = (UnwindingEdge)path.get(i+1);
			smtEdgeAnnotations = edge.getSMTAnnotations();
			//getting the outgoing variables of the edge
			HashMap<String, TermVariable> incomingVariablesOfEdge = smtEdgeAnnotations.getInVars();
			outgoingVariablesOfEdge = smtEdgeAnnotations.getOutVars();
			variablesOfEdge = smtEdgeAnnotations.getVars();

			//add node and edge variables to n_vars
			newVariables.addAll(variablesOfEdge);	
			
			//getting the formula of the edge(assumption)
			Formula assumption = smtEdgeAnnotations.getAssumption();
			//building new formula but yet without mapping of in- and outgoing variables

			//formula = m_theory.and(assertion, assumption);
			formula = assumption;
			
			for(String vname: incomingVariablesOfEdge.keySet()){
				//if an outgoing constant has been declared for this incoming variable of the node then ...
				if (!outConstants.keySet().contains(vname)){
					//s_Logger.debug("This incoming variable " + vname + ": " + incomingVariablesOfEdge.get(vname).toString() + " of the node " + m_ShortestPath.get(i) +
					//		" has not been declared anywhere on the path \n" + m_ShortestPath.toString());
					outConstants.put(vname, makeConstant(incomingVariablesOfEdge.get(vname)));
				}
				TermVariable in_var = incomingVariablesOfEdge.get(vname);
				Term const_Term = outConstants.get(vname);
				formula = m_theory.let(in_var, const_Term, formula);
				allLetStatementsOfNode.put(const_Term, in_var);
				newVariables.remove(in_var);
			}
		} else {
			//node is end of path
//			formula = assertion;
			formula = Atom.TRUE;
		}
		//iterating through all incoming variables of the node/edge
		for(String vname: incomingVariablesOfNode.keySet()){
			//if a outgoing constant has been declared for this incoming variable of the node then ...
			if (!outConstants.keySet().contains(vname)){
				s_Logger.debug("This incoming variable " + vname + ": " + incomingVariablesOfNode.get(vname).toString() + " of the node " + path.get(i) +
						" has not been declared anywhere on the path \n" + path.toString());
				outConstants.put(vname, makeConstant(incomingVariablesOfNode.get(vname)));
			}
			TermVariable in_var = incomingVariablesOfNode.get(vname);
			Term const_Term = outConstants.get(vname);
			formula = m_theory.let(in_var, const_Term, formula);
			allIncomingConstantsOfNode.put(const_Term, in_var);
			allLetStatementsOfNode.put(const_Term, in_var);
			newVariables.remove(in_var);
		}
		//make new constants only if there exists an outgoing edge
		if (edge != null){
			//get the incoming variables of the edge
			HashMap<String, TermVariable> in_vars_edge = smtEdgeAnnotations.getInVars();
			//iterating through all outgoing variables of the edge in order to declare constants and add them to out_constants
			for (String vname: outgoingVariablesOfEdge.keySet()){
				//check if this outgoing variable has really been changed or not
				if (in_vars_edge.containsValue(outgoingVariablesOfEdge.get(vname))){
					//if variable is also incoming variable then skip it
					continue;
				}
				//create new constant term for variable
				Term const_Term = makeConstant(outgoingVariablesOfEdge.get(vname));
				//map new constant to variable name
				outConstants.put(vname, const_Term);
				//map out going variable to new constant
				TermVariable out_var = outgoingVariablesOfEdge.get(vname);
				formula = m_theory.let(out_var, const_Term, formula);
				allLetStatementsOfNode.put(const_Term, out_var);
				newVariables.remove(out_var);
			}
		}
		//Check all remaining variables of the node which are not in or out variables
		for (TermVariable var: newVariables){
			Term const_Term = makeConstant(var);
			formula = m_theory.let(var, const_Term, formula);
			allLetStatementsOfNode.put(const_Term, var);
		}
//		SCNodeAnnotations scAnnotations = (SCNodeAnnotations)node.getPayload().getAnnotations().get("SC");
//		if (scAnnotations == null){
//			scAnnotations = new SCNodeAnnotations();
//			node.getPayload().getAnnotations().put("SC", scAnnotations);
//		}
//		scAnnotations.m_constants = allLetStatementsOfNode;
		return formula;
	}

	/*returns new constant for variable or
	 * returns constant that has already been created for this variable before
	 */
	private Term makeConstant(TermVariable tv){
		//new name for constant variable
		String constName = tv.getName() + "_const";
		//need a list of sorts of the input parameters of the function
		Sort[] dummy_Sorts = {};
		/*faking constant by creating function without input parameters and getting function symbol of newly created fake constant or
		 * of old fake constant that has already been created before*/
		FunctionSymbol fsym = m_theory.getFunction(constName, dummy_Sorts);
		if (fsym == null)
			fsym = m_theory.createFunction(constName, dummy_Sorts, tv.getSort());
		//need list of terms for input parameters of function in order to create term out of it
		Term[] dummyTerms = {};
		//making constant term and returning it
		Term const_Term = m_theory.term(fsym, dummyTerms);
//		const_to_Variable.put(const_Term, tv);
		m_ConstantsToVariableName.put(const_Term, tv.getName());
		return const_Term;
	}
	
	/*returns new constant for variable or
	 * returns constant that has already been created for this variable before
	 */
	private Term makeConstant(TermVariable tv, String name){
		//new name for constant variable
		String constName = tv.getName() + "_const";
		//need a list of sorts of the input parameters of the function
		Sort[] dummy_Sorts = {};
		/*faking constant by creating function without input parameters and getting function symbol of newly created fake constant or
		 * of old fake constant that has already been created before*/
		FunctionSymbol fsym = m_theory.getFunction(constName, dummy_Sorts);
		if (fsym == null)
			fsym = m_theory.createFunction(constName, dummy_Sorts, tv.getSort());
		//need list of terms for input parameters of function in order to create term out of it
		Term[] dummyTerms = {};
		//making constant term and returning it
		Term const_Term = m_theory.term(fsym, dummyTerms);
//		const_to_Variable.put(const_Term, tv);
		m_ConstantsToVariableName.put(const_Term, name);
		return const_Term;
	}
	
}
/*
 * the comparator for UnwindingNodes: It takes care that Error Locations are 
 * always sorted in at the beginning and, at second priority, takes the order of the 
 * expansion of the nodes into account - sort of preorder..
 */
class UNWComparator implements Comparator<UnwindingNode> {

	@Override
	public int compare(UnwindingNode o1, UnwindingNode o2) {
		if(o1 instanceof UnwindingErrorLocation) {
			if(o2 instanceof UnwindingErrorLocation) {
				if(o1.equals(o2)) {
					return 0;
				}
				else {
					return -1;
				}
			}
			else {
				return -1;				
			}

		}
		else if (o2 instanceof UnwindingErrorLocation){
			return 1;
		}
		else {//TODO: - richtigrum? - scheint so..
			return o1.getIndexInPreorder() - o2.getIndexInPreorder();	
		}
	}
	
}