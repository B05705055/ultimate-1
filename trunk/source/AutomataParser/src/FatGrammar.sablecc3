Package de.uni_freiburg.informatik.ultimate.automata.parser.TestGrammar;

Helpers
  all = [0..0xFFFF];
  letter = ['a'..'z'] | ['A'..'Z'] | ['0'..'9'] | '_';
  letter_extended = ['a'..'z'] | ['A'..'Z'] | ['0'..'9'] 
    | '_' 
    | '<' 
    | '>'
    | ' ' 
    | '=' 
    | 0x29 
    | ''' 
    | '[' 
    | ']'
    | '|'
    | '!'
    | ';'
    | ':'
    | '#'
    | '('
    | ')'
    | '{'
    | '}'
    | '$'
    | '.'
    | ','
    | '+'
    | '-'
    | '*'
    | '/'
    | '&'
    | 'â‚¬'
    | '~';

  tab = 9;
  lf = 10; // line feed, 10/0x000a
  cr = 13; // carriage return, 13/0x000d
  eol = lf | cr | cr lf;
  not_cr_lf = [all - [cr + lf]];

  white_space = (' ' | tab | eol)+;
  short_comment = ('/' '/' not_cr_lf* eol);
  quotation_mark = '"'; 



Tokens
  white_space = white_space;
  comment = short_comment;

  equal = ':='; // eq
  l_paren = '('; // lp
  r_paren = ')'; // rp
  l_brace = '{';  // lb
  r_brace = '}';  // rb
  l_brak = '['; // lp
  r_brak = ']'; // rp
  comma = ',';  // c
  hash = '#';



  id_unquoted = letter+;  // non-empty identifier
  id_quoted = quotation_mark letter_extended+ quotation_mark;
  call_tag = '<';
  return_tag = '>';
//  tagged_id = letter+;

  nwa = '#nwa';
  net = '#net';

  call_alphabet = '#callAlphabet';
  internal_alphabet = '#internalAlphabet';
  return_alphabet = '#returnAlphabet';

  states = '#states';
  initial_states = '#initialStates';
  final_states = '#finalStates';

  call_transitions = '#callTransitions';
  internal_transitions = '#internalTransitions';
  return_transitions = '#returnTransitions';
  
  alphabet = '#alphabet';
  places = '#places';
  net_transitions = '#transitions';
  initial_marking = '#initialMarking';
  accepting_markings = '#acceptingMarkings';
  accepting_places = '#acceptingPlaces';


Ignored Tokens
  white_space, comment; // comma as delimiter


Productions

  test_file {-> test_file} = 
    test_case* automaton_definition*
    {-> New test_file([test_case], [automaton_definition])};

  test_case {-> test_case} = 
      {nested_word} [h1]:hash id_unquoted expression l_brak nested_word r_brak
      {-> New test_case.nested_word	(id_unquoted, expression, nested_word)}
    | {nested_lasso_word} hash id_unquoted expression l_brak [stem]:nested_word comma 
    	[loop]:nested_word r_brak
      {-> New test_case.nested_lasso_word(id_unquoted, expression, stem, loop)}
    | {no_word} hash id_unquoted expression
      {-> New test_case.no_word(id_unquoted, expression)};

  expression {-> expression} = 
      {operation} id_unquoted l_paren [expressions]:expression* r_paren 
      {-> New expression.operation(id_unquoted, [expressions])}
    | {automaton_name} identifier {-> New expression.automaton_name(identifier)};
    
  tagged_symbol {-> tagged_symbol} = 
      {call} identifier call_tag
      {-> New tagged_symbol.call(identifier)}
    | {internal} identifier
      {-> New tagged_symbol.internal(identifier)}
    | {return} return_tag identifier
      {-> New tagged_symbol.return(identifier)};

  nested_word {-> nested_word} = [nested_word]:tagged_symbol* 
  	{-> New nested_word([nested_word])};

  call_transition {-> call_transition} = 
    [lp11]:l_paren [predecessor1]:identifier [symbol1]:identifier [successor1]:identifier [rp11]:r_paren
    {-> New call_transition(predecessor1, symbol1, successor1)};

  internal_transition {-> internal_transition} = 
    [lp12]:l_paren [predecessor2]:identifier [symbol2]:identifier [successor2]:identifier [rp12]:r_paren
    {-> New internal_transition(predecessor2, symbol2, successor2)};

  return_transition {-> return_transition} = 
    [lp13]:l_paren [predecessor3]:identifier [linear_predecessor]:identifier [symbol3]:identifier 
    [successor3]:identifier [rp13]:r_paren
    {-> New return_transition(predecessor3, linear_predecessor, symbol3, 
    successor3)};

  net_transition {-> net_transition} = [lp_outer]:l_paren [lp1]:l_brace 
  [predecessors]:identifier* [rp1]:r_brace [symbol]:identifier 
  [lp2]:l_brace [successors]:identifier* [rp2]:r_brace [rp_outer]:r_paren
  	{-> New net_transition([predecessors], symbol, [successors])};
  	
  marking {-> marking} = [lb1]:l_brace [places]:identifier* [rb1]:r_brace
  	{->New marking([places])};

  automaton_definition {-> automaton_definition} = 
  	{nwa} 
    	nwa identifier [eq1]:equal [lp1]:l_paren
    	call_alphabet [eq2]:equal [lb1]:l_brace [call]:identifier* [rb1]:r_brace [c1]:comma
    	internal_alphabet [eq3]:equal [lb2]:l_brace [internal]:identifier* [rb2]:r_brace [c2]:comma
    	return_alphabet [eq4]:equal [lb3]:l_brace [return]:identifier* [rb3]:r_brace [c3]:comma
    	states [eq5]:equal [lb4]:l_brace [state]:identifier* [rb4]:r_brace [c4]:comma
    	initial_states [eq6]:equal [lb5]:l_brace [initial]:identifier* [rb5]:r_brace [c5]:comma
    	final_states [eq7]:equal [lb6]:l_brace [final]:identifier* [rb6]:r_brace [c6]:comma
    	call_transitions [eq8]:equal [lb7]:l_brace call_transition* [rb7]:r_brace [c7]:comma
    	internal_transitions [eq9]:equal [lb8]:l_brace internal_transition* [rb8]:r_brace [c8]:comma
    	return_transitions [eq10]:equal [lb9]:l_brace return_transition* [rb9]:r_brace
    	[rp1]:r_paren
    	{-> New automaton_definition.nwa(identifier, [call], [internal], [return], [state], [initial], [final], [call_transition.call_transition], [internal_transition.internal_transition], [return_transition.return_transition])}
    | {petri_net_jan}
    	net identifier [eq1]:equal [lp1]:l_paren
    	alphabet [eq2]:equal [lb1]:l_brace [alpha]:identifier* [rb1]:r_brace [c1]:comma
    	places [eq3]:equal [lb2]:l_brace [place]:identifier* [rb2]:r_brace [c2]:comma
    	net_transitions [eq4]:equal [lb3]:l_brace [transition]:net_transition* [rb3]:r_brace [c3]:comma
    	initial_marking [eq5]:equal [initial]:marking [c4]:comma
    	accepting_markings [eq6]:equal [lb4]:l_brace [accepting]:marking* [rb4]:r_brace
    	[rp1]:r_paren
    	{-> New automaton_definition.netjan(identifier, [alpha], [place], [transition], initial, [accepting])}
    | {petri_net_julian}
    	net identifier [eq1]:equal [lp1]:l_paren
    	alphabet [eq2]:equal [lb1]:l_brace [alpha]:identifier* [rb1]:r_brace [c1]:comma
    	places [eq3]:equal [lb2]:l_brace [place]:identifier* [rb2]:r_brace [c2]:comma
    	net_transitions [eq4]:equal [lb3]:l_brace [transition]:net_transition* [rb3]:r_brace [c3]:comma
    	initial_marking [eq5]:equal [initial]:marking [c4]:comma
    	accepting_places [eq6]:equal [lb4]:l_brace [accepting]:identifier* [rb4]:r_brace
    	[rp1]:r_paren
    	{-> New automaton_definition.netjulian(identifier, [alpha], [place], [transition], initial, [accepting])};

  identifier {-> identifier } = 
      {unquoted} id_unquoted {-> New identifier.unquoted(id_unquoted)}
    | {quoted} id_quoted {-> New identifier.quoted(id_quoted)};


Abstract Syntax Tree

  test_file = [test_case]:test_case* [automaton_definition]:automaton_definition*;
  
  test_case = {nested_word} [test_operation]:id_unquoted [expression]:expression [nested_word]:nested_word
            | {nested_lasso_word} [test_operation]:id_unquoted [expression]:expression [stem]:nested_word [loop]:nested_word
            | {no_word} [test_operation]:id_unquoted [expression]:expression;

  expression = {operation} [operation]:id_unquoted [expressions]:expression* 
  | {automaton_name} [name]:identifier;
  
   tagged_symbol = {call} [symbol]:identifier
            | {internal} [symbol]:identifier
            | {return} [symbol]:identifier;

  nested_word = [nested_word]:tagged_symbol*;

  call_transition = [predecessor]:identifier [symbol]:identifier [successor]:identifier;

  internal_transition = [predecessor]:identifier [symbol]:identifier [successor]:identifier;
	
  return_transition = [predecessor]:identifier  [linear_predecessor]:identifier [symbol]:identifier 
  [successor]:identifier;
  
  net_transition = [predecessors]:identifier* [symbol]:identifier [successors]:identifier*; 
  
  marking = [places]:identifier*;
	
  automaton_definition =
  	{nwa}
    	[name]:identifier
    	[call_alphabet]:identifier*
    	[internal_alphabet]:identifier*
    	[return_alphabet]:identifier*
    	[states]:identifier*
    	[initial_states]:identifier*
    	[final_states]:identifier*
    	[call_transitions]:call_transition*
    	[internal_transitions]:internal_transition*
    	[return_transitions]:return_transition*
    | {netjan}
    	[name]:identifier
    	[alphabet]:identifier*
    	[places]:identifier*
    	[transitions]:net_transition*
    	[initial_marking]:marking
    	[accepting_markings]:marking*
    | {netjulian}
    	[name]:identifier
    	[alphabet]:identifier*
    	[places]:identifier*
    	[transitions]:net_transition*
    	[initial_marking]:marking
    	[accepting_places]:identifier*;

  identifier = 
      {unquoted} [id]:id_unquoted
      | {quoted} [id]:id_quoted;
