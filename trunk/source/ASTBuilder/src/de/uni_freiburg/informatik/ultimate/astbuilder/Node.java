/*
 * Copyright (C) 2015 Daniel Dietsch (dietsch@informatik.uni-freiburg.de)
 * Copyright (C) 2015 University of Freiburg
 * 
 * This file is part of the ULTIMATE ASTBuilder plug-in.
 * 
 * The ULTIMATE ASTBuilder plug-in is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * The ULTIMATE ASTBuilder plug-in is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 * 
 * You should have received a copy of the GNU Lesser General Public License
 * along with the ULTIMATE ASTBuilder plug-in. If not, see <http://www.gnu.org/licenses/>.
 * 
 * Additional permission under GNU GPL version 3 section 7:
 * If you modify the ULTIMATE ASTBuilder plug-in, or any covered work, by linking
 * or combining it with Eclipse RCP (or a modified version of Eclipse RCP), 
 * containing parts covered by the terms of the Eclipse Public License, the 
 * licensors of the ULTIMATE ASTBuilder plug-in grant you additional permission 
 * to convey the resulting work.
 */
/* Node -- Automatically generated by TreeBuilder */

package de.uni_freiburg.informatik.ultimate.astbuilder;
import java.util.HashSet;

/**
 * Represents a node.
 */
public class Node {
    /**
     * The name of this node.
     */
    String name;

    /**
     * The parent of this node.
     */
    Node parent;

    /**
     * The interfaces of this node.
     */
    String interfaces;

    /**
     * The comment of this node.
     */
    String comment;

    /**
     * The used types of this node.
     */
    HashSet<String> usedTypes;

    /**
     * True iff this node is abstract.
     */
    boolean isAbstract;

    /**
     * The parameters of this node.
     */
    Parameter[] parameters;

    /**
     * The constructor taking initial values.
     * @param name the name of this node.
     * @param parent the parent of this node.
     * @param interfaces the interfaces of this node.
     * @param comment the comment of this node.
     * @param usedTypes the used types of this node.
     */
    public Node(String name, Node parent, String interfaces, String comment, HashSet<String> usedTypes) {
        super();
        this.name = name;
        this.parent = parent;
        this.interfaces = interfaces;
        this.comment = comment;
        this.usedTypes = usedTypes;
    }

    /**
     * The constructor taking initial values.
     * @param name the name of this node.
     * @param parent the parent of this node.
     * @param interfaces the interfaces of this node.
     * @param comment the comment of this node.
     * @param usedTypes the used types of this node.
     * @param isAbstract true iff this node is abstract.
     * @param parameters the parameters of this node.
     */
    public Node(String name, Node parent, String interfaces, String comment, HashSet<String> usedTypes, boolean isAbstract, Parameter[] parameters) {
        super();
        this.name = name;
        this.parent = parent;
        this.interfaces = interfaces;
        this.comment = comment;
        this.usedTypes = usedTypes;
        this.isAbstract = isAbstract;
        this.parameters = parameters;
    }

    /**
     * Returns a textual description of this object.
     */
    public String toString() {
        StringBuffer sb = new StringBuffer();
        sb.append("Node").append('[');
        sb.append(name);
        sb.append(',').append(parent);
        sb.append(',').append(interfaces);
        sb.append(',').append(comment);
        sb.append(',').append(usedTypes);
        sb.append(',').append(isAbstract);
        sb.append(',');
        if (parameters == null) {
            sb.append("null");
        } else {
            sb.append('[');
            for(int i1 = 0; i1 < parameters.length; i1++) {
                if (i1 > 0) sb.append(',');
                    sb.append(parameters[i1]);
            }
            sb.append(']');
        }
        return sb.append(']').toString();
    }

    /**
     * Gets the name of this node.
     * @return the name of this node.
     */
    public String getName() {
        return name;
    }

    /**
     * Gets the parent of this node.
     * @return the parent of this node.
     */
    public Node getParent() {
        return parent;
    }

    /**
     * Gets the interfaces of this node.
     * @return the interfaces of this node.
     */
    public String getInterfaces() {
        return interfaces;
    }

    /**
     * Gets the comment of this node.
     * @return the comment of this node.
     */
    public String getComment() {
        return comment;
    }

    /**
     * Gets the used types of this node.
     * @return the used types of this node.
     */
    public HashSet<String> getUsedTypes() {
        return usedTypes;
    }

    /**
     * Checks iff this node is abstract.
     * @return true iff this node is abstract.
     */
    public boolean isAbstract() {
        return isAbstract;
    }

    /**
     * Sets iff this node is abstract.
     * @param isAbstract true iff this node is abstract.
     */
    public void setAbstract(boolean isAbstract) {
        this.isAbstract = isAbstract;
    }

    /**
     * Gets the parameters of this node.
     * @return the parameters of this node.
     */
    public Parameter[] getParameters() {
        return parameters;
    }

    /**
     * Sets the parameters of this node.
     * @param parameters the parameters of this node.
     */
    public void setParameters(Parameter[] parameters) {
        this.parameters = parameters;
    }
}
