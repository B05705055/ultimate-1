/* Author: Betim Musa
   Date:   29.11.2012
   This file contains the grammar for the automata test files. */

package de.uni_freiburg.informatik.ultimate.plugins.source.automatascriptparser;
import de.uni_freiburg.informatik.ultimate.plugins.source.automatascriptparser.AST.*;
import de.uni_freiburg.informatik.ultimate.plugins.source.automatascriptparser.AutomataScriptLocation; 
import de.uni_freiburg.informatik.ultimate.automata.nwalibrary.INestedWordAutomaton;
import de.uni_freiburg.informatik.ultimate.automata.petrinet.julian.PetriNetJulian;
import de.uni_freiburg.informatik.ultimate.automata.petrinet.julian.BranchingProcess;
import de.uni_freiburg.informatik.ultimate.model.location.ILocation;
import java.util.*;
import java_cup.runtime.*;

action code {:
    // Here I store the variables, which occur during parsing a file, and their types.
    private Hashtable<String, Class<?>> m_varDeclarations = new Hashtable<String, Class<?>>();

    private List<String> m_filesToParse = new ArrayList<String>();

    private AutomataDefinitionsAST m_automataDefinitions = new AutomataDefinitionsAST();
    
    public ILocation getLocation(Symbol sBegin, Symbol sEnd) {
       int startLine = sBegin.left + 1;
       int endLine = sEnd.left + 1;
       int startColumn = sBegin.right + 1;
       int endColumn = sEnd.right + 1;
       return new AutomataScriptLocation(parser.getFileName(), startLine, endLine, startColumn, endColumn);
    }
    
    public void reportError(boolean stopParsing, ILocation loc) {
    	reportError(stopParsing, loc.toString());
    }
    
    public void reportError(boolean stopParsing, String message) {
        AutomataScriptParser.s_Logger.info(message);
        if (stopParsing) {
           throw new RuntimeException(message);
        }
    }
    
    public boolean containsOtherAutomataFilesToParse() {
    	return m_filesToParse.size() != 0;
    }
    
    public List<String> getFilesToParse() {
    	return m_filesToParse;
    }
:};

parser code {:
    private String m_fileName;    
    private String m_filePath;
    private String m_errorMessageLong;
    private String m_errorMessageShort;
    private ILocation m_errorLocation;
    
    public void setFileName(String filename) {
       this.m_fileName = filename;
    }
    
    public void setFilePath(String path) {
    	m_filePath = path;
    }
    
    public String getFileName() {
    	return m_fileName;
    }
    
    public String getFilePath() {
    	return m_filePath;
    }
    
    public String getLongErrorMessage() {
    	return m_errorMessageLong;
    }
    
    public String getShortErrorMessage() {
    	return m_errorMessageShort;
    }
    
    public ILocation getErrorLocation() {
    	return m_errorLocation;
    }
   

    @Override
    public void syntax_error(Symbol cur_token)
    {
    	m_errorMessageShort = "Syntax error";
        java_cup.runtime.Scanner s = getScanner();
        m_errorMessageLong = "";
        if (s instanceof Lexer) {
          Lexer lex = (Lexer) s;
          m_errorMessageLong = "Current token: " + lex.getCurrentToken() +
                               " Last token: " + lex.getLastToken();
        }
        
        m_errorLocation = action_obj.getLocation(cur_token, cur_token);
        report_error("Syntax error", cur_token);
        report_error("Parsing aborted.", null);
    }
    @Override
    public void report_error(String message, Object sym) {
    	Symbol info;
        if (sym != null) {
           info = (Symbol) sym;
        } else {
           info = null;
        }
        
        StringBuffer m = new StringBuffer(getFileName() + ": ");
        if (message != null) { 
        	m.append(message);
        } else {
        	m.append("Error");
        }

        if (info != null) {
            java_cup.runtime.Scanner s = getScanner();
    		if (s instanceof Lexer) {
    			m.append(" on token \"" + ((Lexer) s).getCurrentToken() + "\"");
    		}
    		
        	/* Check if the line number in the input is greater or
               equal to zero. */
        	if (info.left >= 0) {                
        		/* Add to the end of the StringBuffer error message
                   the line number of the error in the input. */
        		m.append(" in line "+(info.left+1));   
        		/* Check if the column number in the input is greater
                   or equal to zero. */
        		if (info.right >= 0)                    
        			/* Add to the end of the StringBuffer error message
                       the column number of the error in the input. */
        			m.append(", column "+(info.right+1));		
        	}
        }
        AutomataScriptParser.s_Logger.debug(m);
    }
   
    @Override
    public void report_fatal_error(String message, Object info) {
    }
    
    @Override
    public void unrecovered_syntax_error(Symbol cur_token) {
    }
    
    public boolean containsOtherAutomataFilesToParse() {
    	return action_obj.containsOtherAutomataFilesToParse();
    }
    
    public List<String> getFilesToParse() {
    	return action_obj.getFilesToParse();
    }

 :}


 /* -------------------- Specification of the Grammar -----------------------*/



 /* -------------------- Specification of terminal symbols -----------*/
terminal Object BOOLEAN; // primitive_type
terminal Object INT; // integral_type
terminal Object STRING;
terminal Object LBRACK, RBRACK;
terminal Object SEMICOLON, COMMA, EQ, LBRACE, RBRACE, LPAREN, RPAREN, COLON;
terminal Object IF, ELSE; // if_then_statement, if_then_else_statement
terminal Object WHILE; // while_statement
terminal Object FOR; // for_statement
terminal Object BREAK; // break_statement
terminal Object CONTINUE; // continue_statement
terminal Object RETURN; // return_statement
terminal UnaryOperatorAST PLUSPLUS; // postincrement_expression
terminal UnaryOperatorAST MINUSMINUS; // postdecrement_expression
terminal BinaryOperatorAST PLUS, MINUS, DIV, MULT, MOD;
terminal RelationalOperatorAST LT, GT, LTEQ, GTEQ; // relational_expression, and call or return symbol for nested words
terminal RelationalOperatorAST EQEQ, NOTEQ; // equality_expression
terminal ConditionalBooleanOperatorAST NOT; 
terminal ConditionalBooleanOperatorAST ANDAND; // conditional_and_expression
terminal ConditionalBooleanOperatorAST OROR; // conditional_or_expression
terminal Object QUESTION; // conditional_expression
terminal AssignmentOperatorAST MULTEQ, DIVEQ, MODEQ, PLUSEQ, MINUSEQ; // assignment_operator

terminal Object NESTED_WORD, NESTED_LASSO_WORD; 

terminal java.lang.Integer INTEGER_LITERAL;
terminal java.lang.Boolean BOOLEAN_LITERAL;
terminal java.lang.String STRING_LITERAL;
terminal java.lang.String SIMPLE_IDENTIFIER; 


 /* -------------------- Specification of non-terminal symbols -----------*/
// 1. Start of the grammar
non terminal AtsASTNode automata_test_file;
// 2. Lexical Structure
non terminal AtsASTNode literal;
non terminal String identifier;
// 3. Types
non terminal Class<?> type;
// 5. Variable Declarations
non terminal AtsASTNode variable_declarators, variable_declarator;
non terminal java.lang.String variable_identifier;
// 6. Blocks and Statements
non terminal AtsASTNode test_statement_block;
non terminal AtsASTNode test_statements_opt, test_statements;
non terminal AtsASTNode test_statement;
non terminal AtsASTNode statement;
non terminal AtsASTNode variable_declaration_statement, variable_declaration;
non terminal AtsASTNode statement_without_trailing_substatement;
non terminal AtsASTNode empty_statement;
non terminal AtsASTNode expression_statement, statement_expression;
non terminal AtsASTNode statement_expression_list;
// 6.2 Conditional Statements
// 6.2.1 If Statements
non terminal AtsASTNode if_then_statement;
non terminal AtsASTNode if_then_else_statement;
// 6.2.2 Loop statements
non terminal AtsASTNode while_statement;
non terminal AtsASTNode for_statement;
non terminal AtsASTNode for_init_opt, for_init;
non terminal AtsASTNode for_update_opt, for_update;
//  6.2.3 Special loop statements
non terminal AtsASTNode break_statement, continue_statement;
non terminal AtsASTNode return_statement;
// 7. Expressions
non terminal AtsASTNode expression_opt, expression;
non terminal AtsASTNode operation_invocation;
non terminal AtsASTNode primary;
non terminal ArgumentListAST argument_list_opt, argument_list;
non terminal AtsASTNode postfix_expression;
non terminal AtsASTNode postincrement_expression, postdecrement_expression;
non terminal AtsASTNode preincrement_expression, predecrement_expression;
non terminal AtsASTNode unary_expression;
non terminal AtsASTNode multiplicative_expression, additive_expression;
non terminal AtsASTNode assignment;
non terminal AssignmentOperatorAST assignment_operator;
non terminal AtsASTNode left_hand_side;
// 7.1 Boolean Expressions
non terminal AtsASTNode conditional_expression;
non terminal AtsASTNode conditional_and_expression, conditional_or_expression;
non terminal AtsASTNode relational_expression, equality_expression;
non terminal AtsASTNode unary_expression_not_plus_minus;
// 8. Words
non terminal AtsASTNode word_literal;
non terminal NestedwordAST nested_word, nested_word_symbols_opt, nested_word_symbols; 
non terminal Object nested_word_symbol;

 /* -------------------- Specification of Automata DEFINITION Files-----------------------*/
 /* -------------------- Specification of terminals   -----------------------*/
 // 1. Automata Types
 terminal Object NESTEDWORD_AUTOMATA, PETRINET_AUTOMATA, BRANCHINGPROCESS_AUTOMATA;
 // 2. Alphabets
 terminal Object ALPHABET, CALL_ALPHABET, INTERNAL_ALPHABET, RETURN_ALPHABET;
// 3. States & Places
terminal Object STATES, PLACES, INITIAL_STATES, FINAL_STATES;
// 4. Transitions
terminal Object NET_TRANSITIONS, INTERNAL_TRANSITIONS, CALL_TRANSITIONS, RETURN_TRANSITIONS;
// 5. 
terminal Object INITIAL_MARKINGS, ACCEPTING_PLACES;
 /* -------------------- Specification of non-terminals   -----------------------*/
non terminal IdentifierListAST identifier_list_opt, identifier_list;
// Automata types
non terminal AutomatonAST nwa_definition, petrinetJulian_definition;
// Alphabets
non terminal IdentifierListAST alphabet_opt, petrinet_alphabet, call_alphabet, return_alphabet_opt, return_alphabet, internal_alphabet_opt, internal_alphabet;
// States & Places
non terminal IdentifierListAST states_opt, states, initial_states_opt, initial_states, final_states_opt, final_states;  
non terminal IdentifierListAST places, accepting_places;
// Transitions & Markings
non terminal TransitionListAST call_transitions_opt, call_transitions, internal_transitions_opt, internal_transitions; 
non terminal TransitionListAST return_transitions_opt, return_transitions, transition_list, transition_list_opt;
non terminal IdentifierListAST transition;
non terminal TransitionListAST net_transitions, net_transition_list_opt, net_transition_list; 
non terminal PetriNetTransitionAST  net_transition;
non terminal IdentifierListAST marking;
non terminal PetriNetMarkingListAST initial_markings;



 /* -------------------- Specification of the Rules -------------------------*/

start with automata_test_file;

// 1. Start of the grammar
automata_test_file ::= test_statement_block:stmtList
                       {: AutomataTestFileAST ats = new AutomataTestFileAST(stmtList, m_automataDefinitions); 
                          RESULT = ats; :};

// 2. Lexical Structure
literal ::=	INTEGER_LITERAL:i 
                {: ConstantExpressionAST c = new ConstantExpressionAST(i);
                   c.setLocation(getLocation(i$, i$));
                   RESULT = c;:}
    	|	BOOLEAN_LITERAL:b
                {: ConstantExpressionAST c = new ConstantExpressionAST(b);
                   c.setLocation(getLocation(b$, b$));
                   RESULT = c;:}
        |       STRING_LITERAL:s
                {: ConstantExpressionAST c = new ConstantExpressionAST(s);
                   c.setLocation(getLocation(s$, s$));
                   RESULT = c; :}
        |       word_literal:w
                {: RESULT = w; :}
	   ;
	   
	   
identifier ::= SIMPLE_IDENTIFIER:i {: RESULT = i; :}
            |   STRING_LITERAL:s {: RESULT = s; :}; 

word_literal ::= LBRACK:l nested_word:nw RBRACK:r /* Parse a nested word */
                 {: nw.setLocation(getLocation(l$, r$));
                    RESULT = nw; :}
        |        LBRACK:l nested_word:nw1 COMMA nested_word:nw2 RBRACK:r /* Parse lasso word */
        		 {: NestedLassowordAST nlw = new NestedLassowordAST(nw1, nw2);
                    nlw.setLocation(getLocation(l$, r$)); 
                    RESULT = nlw; :}
        ;
                

nested_word ::= nested_word_symbols_opt:nw {: RESULT = nw; :};

nested_word_symbols_opt ::= nested_word_symbols:nw {: RESULT = nw; :} | {: RESULT = new NestedwordAST(); :};

nested_word_symbols ::= nested_word_symbol:sym
						{: NestedwordAST nw = new NestedwordAST();
						   if (sym instanceof CallSymbolAST) {
							   nw.addSymbol((CallSymbolAST)sym);
						   } else if (sym instanceof InternalSymbolAST) {
							   nw.addSymbol((InternalSymbolAST)sym);
						   } else if (sym instanceof ReturnSymbolAST) {
							   nw.addSymbol((ReturnSymbolAST)sym);
						   }
						  RESULT = nw; :}
                      | nested_word_symbols:nsw nested_word_symbol:sym
						{:  if (sym instanceof CallSymbolAST) {
							   nsw.addSymbol((CallSymbolAST)sym);
						   } else if (sym instanceof InternalSymbolAST) {
							   nsw.addSymbol((InternalSymbolAST)sym);
						   } else if (sym instanceof ReturnSymbolAST) {
							   nsw.addSymbol((ReturnSymbolAST)sym);
						   }
						  RESULT = nsw; :}
                      ;

nested_word_symbol ::= identifier:i        /* This is an internal symbol */ 
                       {: RESULT = new InternalSymbolAST(i); :}
        |              identifier:i LT  /* This is a call symbol */
                       {: RESULT = new CallSymbolAST(i); :}
        |              GT identifier:i    /* This is a return symbol */
                       {: RESULT = new ReturnSymbolAST(i); :}
        ;
          
// 3. Types
type	::=     INT
                {: RESULT = Integer.class; :}
        |       BOOLEAN
                {: RESULT = Boolean.class; :}
        |       STRING
                {: RESULT = String.class; :}
        |       NESTED_WORD
        		{: RESULT = de.uni_freiburg.informatik.ultimate.automata.nwalibrary.NestedWord.class; :}
        |       NESTED_LASSO_WORD
        		{: RESULT = de.uni_freiburg.informatik.ultimate.automata.nwalibrary.buchiNwa.NestedLassoWord.class; :}
        |       NESTEDWORD_AUTOMATA
                {: RESULT = INestedWordAutomaton.class; :}
        |       PETRINET_AUTOMATA         
                {: RESULT = PetriNetJulian.class; :}
        |       BRANCHINGPROCESS_AUTOMATA         
                {: RESULT = BranchingProcess.class; :}
                
        ;

// 5. Variable Declarations
variable_declaration ::=
		type:t variable_declarators:varLst
                {: RESULT = varLst;
				   varLst.setLocation(getLocation(t$, varLst$));
				   varLst.setType(t);
                   if (varLst instanceof VariableDeclarationAST) {
                	  for (String id : ((VariableDeclarationAST) varLst).getIdentifiers()) {
                		  m_varDeclarations.put(id, t);
                	  }
                   }:}
        | type:t nwa_definition:nwa
          {: if (t.equals(INestedWordAutomaton.class))
                { nwa.setType(t);
                  m_automataDefinitions.addAutomaton(nwa);}
             else {reportError(true, "AutomataDefiniton: Type error \"" + t.getSimpleName() + "\" is not compatible with \"INestedWordAutomaton\""); }
             RESULT = null;:}
        | type:t petrinetJulian_definition:petri
          {: if (t.equals(PetriNetJulian.class))
                { petri.setType(t);
                  m_automataDefinitions.addAutomaton(petri);}
             else {reportError(true, "AutomataDefiniton: Type error \"" + t.getSimpleName() + "\" is not compatible with \"PetriNetAutomatonAST\""); }
             RESULT = null;:}
//         | type:t alternatingFiniteAutomata_definition:afa
//                {:
//                 if (t.equals(AlterinatingAutomata.class)) {
/*                        m_automataDefinitions.addAutomaton(afa);
                 } else {
                        reportError(true, "AutomataDefiniton: Type error \"" + 
                        t.getSimpleName() + "\" is not compatible with \"AlternatingAutomaton\""); }
                 }
                :}
                */
	;
variable_declarators ::=
		variable_declarator:v
                {: RESULT = v;
                   v.setLocation(getLocation(v$, v$)); :}
	|	variable_declarators:varLst COMMA variable_declarator:v
                {: RESULT = null;
		   varLst.setLocation(getLocation(varLst$, v$));
                	if (v instanceof VariableDeclarationAST) {
                	((VariableDeclarationAST)varLst).addVariables(((VariableDeclarationAST)v).getIdentifiers());
                   } 
                   RESULT = varLst;:}
	;
variable_declarator ::=
		variable_identifier:v
                {: VariableDeclarationAST var = new VariableDeclarationAST(v);
                   var.setLocation(getLocation(v$, v$)); 
                   RESULT = var; :}
	|	variable_identifier:v EQ expression:e
                {: RESULT = null;
                   VariableDeclarationAST var = new VariableDeclarationAST(v);
                   var.setLocation(getLocation(v$, e$));
	               if (e instanceof AtsASTNode) {
                   var.addOutgoingNode((AtsASTNode) e);
                   RESULT = var;
	               } :}
	         ;
variable_identifier ::= SIMPLE_IDENTIFIER:v {: RESULT = v; :} ;

// 6. Blocks and Statements
test_statement_block ::= test_statements_opt:stmts
                         {: RESULT = stmts; :}
			 ;

test_statements_opt   ::= test_statements:stmts {: RESULT = stmts; :}  | {: RESULT = null; :};

test_statements ::= 
		test_statement:stmt
                {:StatementListAST stmts = new StatementListAST();
				  stmts.setLocation(getLocation(stmt$, stmt$));
                  RESULT = null;
                  if (stmt instanceof AtsASTNode) {
                	  stmts.addOutgoingNode((AtsASTNode) stmt);
                	  RESULT = stmts;
 	          } 
                  RESULT = stmts; :}
	|	test_statements:stmtList test_statement:stmt
                {: RESULT = stmtList;
                  if (stmtList == null) {
                    stmtList = new StatementListAST();
                  }
                  stmtList.setLocation(getLocation(stmtList$, stmt$));
                  if ((stmt instanceof AtsASTNode) && (stmtList instanceof StatementListAST)) {
                    ((StatementListAST) stmtList).addOutgoingNode((AtsASTNode) stmt);
                    RESULT = stmtList;
                  } 
                  :}
	;
test_statement ::= 
		variable_declaration_statement:varstmt
                {: RESULT = varstmt; :}
	|	statement:stmt
                {: RESULT = stmt; :}
        ;


variable_declaration_statement ::=
		variable_declaration:varLst SEMICOLON
                {: RESULT = varLst; :}
	;


statement ::=	statement_without_trailing_substatement:stmt
                {: RESULT = stmt; :}
        |       if_then_statement:stmt
                {: RESULT = stmt; :}
        |       if_then_else_statement:stmt
                {: RESULT = stmt; :}
        |       while_statement:stmt
                {: RESULT = stmt; :}
        |       for_statement:stmt
                {: RESULT = stmt; :}
	;


statement_without_trailing_substatement ::=
		empty_statement
                {: RESULT = null; :}
	|	expression_statement:e
                {: RESULT = e; :}
	|	break_statement:b
                {: BreakStatementAST bs = new BreakStatementAST();
	               bs.setLocation(getLocation(b$, b$)); 
	               RESULT = bs; :}
	|	continue_statement:c
                {: ContinueStatementAST cs = new ContinueStatementAST();
	               cs.setLocation(getLocation(c$, c$));
	               RESULT = cs; :}
	|	return_statement:rt
                {: RESULT = rt; :}
	;

empty_statement ::= SEMICOLON {: RESULT = null; :}	;

expression_statement ::=
		statement_expression:stmt SEMICOLON
                {: RESULT = stmt; :}
	;

statement_expression ::=
		assignment:e
                {: RESULT = e; :}
	|	preincrement_expression:e
                {: RESULT = e; :}
	|	predecrement_expression:e
                {: RESULT = e; :}
	|	postincrement_expression:e
                {: RESULT = e; :}
	|	postdecrement_expression:e
                {: RESULT = e; :}
	|       operation_invocation:e
                {: RESULT = e; :}
        |    NOT:n operation_invocation:e
            {:  RESULT = null;
              ILocation loc  = getLocation(n$, e$);
              if ((e instanceof AtsASTNode)) {
                ConditionalBooleanExpressionAST cbe = new ConditionalBooleanExpressionAST((AtsASTNode) e);
                cbe.setOperator(ConditionalBooleanOperatorAST.NOT);
                cbe.setLocation(loc);
                RESULT = cbe;
              } else {
                reportError(false,  loc);
                reportError(true,  "Parser_CondNotExpr: Expecting AtsASTNode Got:(Cond1) " + (e != null ? e.getClass().getSimpleName(): "null"));
              }:}
	;

// 6.2 Conditional Statements

// 6.2.1 If Statements
if_then_statement ::=
              IF:i LPAREN expression:e RPAREN LBRACE test_statement_block:stmts RBRACE:r
                {: RESULT = null;
	           ILocation loc = getLocation(i$, r$);
                   if ((e instanceof AtsASTNode) && (stmts instanceof AtsASTNode)) {
                     IfStatementAST is = new IfStatementAST((AtsASTNode) e, (AtsASTNode) stmts);
                     is.setLocation(loc);
                     RESULT = is;
                   } 
 	               :}
	;

if_then_else_statement ::=
		IF:i LPAREN expression:e RPAREN LBRACE test_statement_block:stmts1 RBRACE:r
                ELSE LBRACE test_statement_block:stmts2 RBRACE
                {:  
                  RESULT = null;
                  ILocation loc = getLocation(i$, r$);
                  if ((e instanceof AtsASTNode) && (stmts1 instanceof AtsASTNode) && (stmts2 instanceof AtsASTNode)) {
                    IfElseStatementAST is = new IfElseStatementAST((AtsASTNode) e, (AtsASTNode) stmts1, (AtsASTNode) stmts2);
                    is.setLocation(loc);
                    RESULT = is;
                  }
	          :}
	;


// 6.2.2 Loop statements
while_statement ::=
		WHILE:w LPAREN expression:e RPAREN LBRACE test_statement_block:stmts RBRACE:r
                {: RESULT = null;
                  ILocation loc = getLocation(w$, r$);
                  if ((e instanceof AtsASTNode) && (stmts instanceof AtsASTNode)) {
                    WhileStatementAST ws = new WhileStatementAST((AtsASTNode) e, (AtsASTNode) stmts);
                    ws.setLocation(loc);
                    RESULT = ws;
                  }
 	          :} ;


for_statement ::=
		FOR:f LPAREN for_init_opt:init_op SEMICOLON expression_opt:e SEMICOLON
			for_update_opt:update RPAREN LBRACE test_statement_block:stmts RBRACE:r
                {: RESULT = null;
                  ILocation loc = getLocation(f$, r$);
                  if (((init_op == null) || (init_op instanceof AtsASTNode)) && (e instanceof AtsASTNode) && (stmts instanceof AtsASTNode) && (update instanceof AtsASTNode)) {
                    if (init_op != null) {
                      RESULT = new ForStatementAST((AtsASTNode) init_op, (AtsASTNode) e, (AtsASTNode) update, (AtsASTNode) stmts);
                      RESULT.setLocation(loc);
                    } else {
                      RESULT = new ForStatementAST(null, (AtsASTNode) e, (AtsASTNode) update, (AtsASTNode) stmts);
                      RESULT.setLocation(loc);
                    }

                  }
	          :} ;

for_init_opt ::= for_init:e {: RESULT = e; :} | {: RESULT = null; :} ;

for_init ::=	statement_expression_list:e
                {: RESULT = e; :}
	|	variable_declaration:v
                {: RESULT = v; :}
	;

for_update_opt ::= for_update:e {: RESULT = e; :} | {:RESULT = null; :} ;

for_update ::=	statement_expression_list:e {: RESULT = e; :} ;

statement_expression_list ::=
		statement_expression:stmt
                {: RESULT = null;
                  StatementListAST stmts = new StatementListAST();
                  stmts.setLocation(getLocation(stmt$, stmt$));
                  if (stmt instanceof AtsASTNode) {
                    stmts.addOutgoingNode((AtsASTNode) stmt);
                    RESULT = stmts;
                  }
 	               :}
	|	statement_expression_list:stmtlst COMMA statement_expression:stmt
                {: RESULT = null;
                  ILocation loc = getLocation(stmtlst$, stmt$);
                  if (stmt instanceof AtsASTNode) {
                    ((StatementListAST) stmtlst).addOutgoingNode((AtsASTNode) stmt);
                    stmtlst.setLocation(loc);
                    RESULT = stmtlst;
                  } 
 	          :} ;

//  6.2.3 Special loop statements
break_statement ::= BREAK SEMICOLON {:RESULT = null; :} ;

continue_statement ::= CONTINUE SEMICOLON{:RESULT = null; :} ;
return_statement ::=
		RETURN:r expression_opt:e SEMICOLON
                {: ReturnStatementAST rst = new ReturnStatementAST();
                  rst.setLocation(getLocation(r$, e$)); 	
                  if ((e != null) &&(e instanceof AtsASTNode)) {
                    rst.addOutgoingNode((AtsASTNode) e);
                  } 
                   RESULT = rst;:} ;

// 7. Expressions
expression_opt ::= expression:e {: RESULT = e; :} | {:RESULT = null; :} ;
                       
expression ::=
		conditional_expression:c
                {: RESULT = c; :}
	|	assignment:a
                {: RESULT = a; :}
	;
conditional_expression ::=
		conditional_or_expression:c
                {: RESULT = c; :}
	|	conditional_or_expression QUESTION expression 
			COLON conditional_expression
			{: RESULT = null; :}
	;
assignment ::=	left_hand_side:v assignment_operator:op expression:e
                {: RESULT = null;
                  VariableExpressionAST var = null;
                  if (v instanceof VariableExpressionAST) {
                    var = (VariableExpressionAST) v;
                  } else {
                    reportError(false, v.getLocation());
                    reportError(true, "AssignmentExpressionAST: Left-hand side was not a Variable");
                  }
                  if (m_varDeclarations.containsKey(var.getIdentifier())) {
                    var.setType(m_varDeclarations.get(var.getIdentifier()));
                  } 
                  if ((e != null) && (e instanceof AtsASTNode)) {
                    RESULT = new AssignmentExpressionAST(var, op, (AtsASTNode) e);
                    RESULT.setLocation(getLocation(v$, e$));
                  } else if (e == null) {
                    RESULT = new AssignmentExpressionAST(var, op, null);
                    RESULT.setLocation(getLocation(v$, v$));
                  }
                    :} ;

left_hand_side ::= variable_identifier:v 
		{: VariableExpressionAST var = new VariableExpressionAST(v);
                  var.setLocation(getLocation(v$, v$));
                  if ((v != null) && (m_varDeclarations.containsKey(v))) { 
                    var.setType(m_varDeclarations.get(v));
                  }
                  RESULT = var;  
                :} ;

assignment_operator ::=
		EQ
                {: RESULT = AssignmentOperatorAST.ASSIGN; :}
	|	MULTEQ
                {: RESULT = AssignmentOperatorAST.MULTASSIGN; :}
	|	DIVEQ
                {: RESULT = AssignmentOperatorAST.DIVASSIGN; :}
	|	MODEQ
                {: RESULT = AssignmentOperatorAST.MODASSIGN; :}
	|	PLUSEQ
                {: RESULT = AssignmentOperatorAST.PLUSASSIGN; :}
	|	MINUSEQ
                {: RESULT = AssignmentOperatorAST.MINUSASSIGN; :}
	;
conditional_or_expression ::=
		conditional_and_expression:c
                {: RESULT = c; :}
	|	conditional_or_expression:c1 OROR conditional_and_expression:c2
                {: RESULT = null;
                  ILocation loc = getLocation(c1$, c2$);	
                  if ((c1 instanceof AtsASTNode) && (c2 instanceof AtsASTNode)) {
                    ConditionalBooleanExpressionAST cbe = new ConditionalBooleanExpressionAST((AtsASTNode) c1,(AtsASTNode)  c2);
                    cbe.setOperator(ConditionalBooleanOperatorAST.OR);
                    cbe.setLocation(loc);
                    RESULT = cbe;
                  } :} ;

conditional_and_expression ::=
		equality_expression:e
                {: RESULT = e; :}
	|	conditional_and_expression:c1 ANDAND equality_expression:c2
                {: RESULT = null;
                  ILocation loc = getLocation(c1$, c2$);	
                  if ((c1 instanceof AtsASTNode) && (c2 instanceof AtsASTNode)) {
                    ConditionalBooleanExpressionAST cbe = new ConditionalBooleanExpressionAST((AtsASTNode) c1,(AtsASTNode)  c2);
                    cbe.setOperator(ConditionalBooleanOperatorAST.AND);
                    cbe.setLocation(loc);
                    RESULT = cbe;
                  } :}
	;
equality_expression ::=
		relational_expression:e
                {: RESULT = e; :}
	|	equality_expression:e1 EQEQ relational_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.EQ);
                    re.setLocation(loc);
                    RESULT = re;
                  } :}
	|	equality_expression:e1 NOTEQ relational_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.NOT_EQ);
                    re.setLocation(loc);
                    RESULT = re;
	               } :} ;

relational_expression ::=
		additive_expression:e
                {: RESULT = e; :}
	|	relational_expression:e1 LT additive_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.LESSTHAN);
                    re.setLocation(loc);
                    RESULT = re;
                  } :}
	|	relational_expression:e1 GT additive_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.GREATERTHAN);
                    re.setLocation(loc);
                    RESULT = re;
                  } :}
	|	relational_expression:e1 LTEQ additive_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.LESS_EQ_THAN);
                    re.setLocation(loc);
                    RESULT = re;
                  } :}
	|	relational_expression:e1 GTEQ additive_expression:e2
                {: RESULT = null;
                  ILocation loc = getLocation(e1$, e2$);
                  RelationalExpressionAST re = new RelationalExpressionAST();
                  if ((e1 instanceof AtsASTNode) && (e2 instanceof AtsASTNode)) {
                    re.addOutgoingNode((AtsASTNode) e1);
                    re.addOutgoingNode((AtsASTNode) e2);
                    re.setOperator(RelationalOperatorAST.GREATER_EQ_THAN);
                    re.setLocation(loc);
                    RESULT = re;
                  } :} ;

additive_expression ::=
		multiplicative_expression:e
                {: RESULT = e; :}
	|	additive_expression:a PLUS multiplicative_expression:m
                {: RESULT = null;
                  ILocation loc = getLocation(a$, m$);
                  if ((a instanceof AtsASTNode) && (m instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST((AtsASTNode) a, (AtsASTNode) m);
                    be.setOperator(BinaryOperatorAST.PLUS);
                    be.setLocation(loc);
                    RESULT = be;
                  } :}
	|	additive_expression:a MINUS multiplicative_expression:m
                {: RESULT = null;
                  ILocation loc = getLocation(a$, m$);
                  if ((a instanceof AtsASTNode) && (m instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST((AtsASTNode) a, (AtsASTNode) m);
                    be.setOperator(BinaryOperatorAST.MINUS);
                    be.setLocation(loc);
                    RESULT = be;
                  } :} ;

multiplicative_expression ::=
		unary_expression:e
                {: RESULT = e; :}
	|	multiplicative_expression:a MULT unary_expression:m
                {: RESULT = null;
                  ILocation loc = getLocation(a$, m$);
                  if ((a instanceof AtsASTNode) && (m instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST((AtsASTNode) a, (AtsASTNode) m);
                    be.setOperator(BinaryOperatorAST.MULTIPLICATION);
                    be.setLocation(loc);
                    RESULT = be;
                  } :}
	|	multiplicative_expression:a DIV unary_expression:m
                {: RESULT = null;
                  ILocation loc = getLocation(a$, m$);
                  if ((a instanceof AtsASTNode) && (m instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST((AtsASTNode) a, (AtsASTNode) m);
                    be.setOperator(BinaryOperatorAST.DIVISION);
                    be.setLocation(loc);
                    RESULT = be;
                  } :}
	|	multiplicative_expression:a MOD unary_expression:m
                {: RESULT = null;
                  ILocation loc = getLocation(a$, m$);
                  if ((a instanceof AtsASTNode) && (m instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST((AtsASTNode) a, (AtsASTNode) m);
                    be.setOperator(BinaryOperatorAST.MODULO);
                    be.setLocation(loc);
                    RESULT = be;
                  } :} ;

primary ::=
		literal:l
                {: RESULT = l; :}
	|	LPAREN expression:e RPAREN {: RESULT = e; :}
	|	operation_invocation:oi {: RESULT = oi; :}
	;

argument_list_opt ::= argument_list:args {: RESULT = args; :} | {:RESULT = new ArgumentListAST(); :} ;

argument_list ::=
		expression:e
                {: ArgumentListAST al = new ArgumentListAST(e);
                  al.setLocation(getLocation(e$, e$)); 
                  RESULT = al; :}
	|	argument_list:argList COMMA expression:e
                {: ((ArgumentListAST) argList).addArg(e);
                  argList.setLocation(getLocation(argList$, e$));
                  RESULT = argList; :} ;

operation_invocation ::=
		variable_identifier:opName LPAREN argument_list_opt:args RPAREN:r
                {:
                  if (opName.equals("parseAutomata")) {
                    for (Object arg : args.getArguments()) {
                      if (arg instanceof VariableExpressionAST) {
                        m_filesToParse.add(((VariableExpressionAST) arg).getIdentifier());
                      } else if (arg instanceof ConstantExpressionAST) {
                        m_filesToParse.add(((ConstantExpressionAST) arg).getValue().toString());
                      }
                    }
                    RESULT = null;
                  } else {
                    OperationInvocationExpressionAST op = new OperationInvocationExpressionAST(opName, args);
                    op.setLocation(getLocation(opName$, r$));
                    RESULT = op; 
                  }
            :}
	;
postfix_expression ::=
		primary:p
                {: RESULT = p; :}
	|	variable_identifier:v
		{: VariableExpressionAST var = new VariableExpressionAST(v);
                  var.setLocation(getLocation(v$, v$));
                  if ((v != null) && (m_varDeclarations.containsKey(v))) { 
                    var.setType(m_varDeclarations.get(v));
                  }
                  RESULT = var;  
                :}
	|	postincrement_expression:e
                {: RESULT = e; :}
	|	postdecrement_expression:e
                {: RESULT = e; :}
	;
postincrement_expression ::=
		postfix_expression:e PLUSPLUS
                {: RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof VariableExpressionAST)) {
                    UnaryExpressionAST ue = new UnaryExpressionAST((VariableExpressionAST) e);
                    ue.setOperator(UnaryOperatorAST.EXPR_PLUSPLUS);
                    ue.setLocation(loc);
                    RESULT = ue;
                } :} ;

postdecrement_expression ::=
		postfix_expression:e MINUSMINUS
                {: RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof VariableExpressionAST)) {
                    UnaryExpressionAST ue = new UnaryExpressionAST((VariableExpressionAST) e);
                    ue.setOperator(UnaryOperatorAST.EXPR_MINUSMINUS);
                    ue.setLocation(loc);
                    RESULT = ue;
                } :} ;
unary_expression ::=
		preincrement_expression:e
                {: RESULT = e; :}
	|	predecrement_expression:e
                {: RESULT = e; :}
	|	PLUS unary_expression:e
                {: RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST(new ConstantExpressionAST(0), (AtsASTNode) e);
                    be.setOperator(BinaryOperatorAST.PLUS);
                    be.setLocation(loc);
                    RESULT = be;
                  } 
                :}
	|	MINUS unary_expression:e
                {:  RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof AtsASTNode)) {
                    BinaryExpressionAST be = new BinaryExpressionAST(new ConstantExpressionAST(0), (AtsASTNode) e);
                    be.setOperator(BinaryOperatorAST.MINUS);
                    be.setLocation(loc);
                    RESULT = be;
                  } 
                :}
	|	unary_expression_not_plus_minus:e
                {: RESULT = e; :}
	;
preincrement_expression ::=
		PLUSPLUS unary_expression:e
                {: RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof VariableExpressionAST)) {
                    UnaryExpressionAST ue = new UnaryExpressionAST((VariableExpressionAST) e);
                    ue.setOperator(UnaryOperatorAST.PLUSPLUS_EXPR);
                    ue.setLocation(loc);
                    RESULT = ue;
                  } :} ;

predecrement_expression ::=
		MINUSMINUS unary_expression:e
                {: RESULT = null;
                  ILocation loc  = getLocation(e$, e$);
                  if ((e instanceof VariableExpressionAST)) {
                    UnaryExpressionAST ue = new UnaryExpressionAST((VariableExpressionAST) e);
                    ue.setOperator(UnaryOperatorAST.MINUSMINUS_EXPR);
                    ue.setLocation(loc);
                    RESULT = ue;
                  } :} ;

unary_expression_not_plus_minus ::=
		postfix_expression:p
                {: RESULT = p; :}
	|	NOT:n unary_expression:e
                {:  RESULT = null;
                  ILocation loc  = getLocation(n$, e$);
                  if ((e instanceof AtsASTNode)) {
                    ConditionalBooleanExpressionAST cbe = new ConditionalBooleanExpressionAST((AtsASTNode) e);
                    cbe.setOperator(ConditionalBooleanOperatorAST.NOT);
                    cbe.setLocation(loc);
                    RESULT = cbe;
                  } :} ;

/* -------------------- Specification of Rules for Automata DEFINITION Files-----------------------*/

nwa_definition ::=      variable_identifier:id EQ
                        LPAREN:l alphabet_opt:call COMMA
                               internal_alphabet_opt:intern COMMA
                               return_alphabet_opt:ret COMMA
                               states_opt:states COMMA
                               initial_states_opt:init_states COMMA
                               final_states_opt:fin_states COMMA
                               call_transitions_opt:call_trans COMMA
                               internal_transitions_opt:int_trans COMMA
                               return_transitions_opt:ret_trans
                        RPAREN:r
                        {: NestedwordAutomatonAST nwa = new NestedwordAutomatonAST(id);
                          nwa.setCallAlphabet(call.getIdentifierList());
                          nwa.setInternalAlphabet(intern.getIdentifierList());
                          nwa.setReturnAlphabet(ret.getIdentifierList());
                          nwa.setStates(states.getIdentifierList());
                          nwa.setInitialStates(init_states.getIdentifierList());
                          nwa.setFinalStates(fin_states.getIdentifierList());
                          nwa.setInternalTransitions(int_trans);
                          nwa.setCallTransitions(call_trans);
                          nwa.setReturnTransitions(ret_trans);
                          nwa.setLocation(getLocation(l$, r$));
                          m_varDeclarations.put(id, NestedwordAutomatonAST.class);
                          RESULT = nwa; :} ;


call_alphabet ::=  CALL_ALPHABET EQ LBRACE:l identifier_list_opt:idList  RBRACE:r 
				   {:idList.setLocation(getLocation(l$, r$));
					   RESULT = idList; :} ;

identifier_list_opt ::= identifier_list:idList {:RESULT = idList; :} | {:RESULT = new IdentifierListAST(); :};

identifier_list ::= identifier:id
                    {: IdentifierListAST idList = new IdentifierListAST();
                      idList.addId(id);
                      RESULT = idList; :} 
                    | identifier_list:idList identifier:id
                      {:idList.addId(id);
                    	RESULT = idList; :};

alphabet_opt ::= call_alphabet:a {:RESULT = a; :} | petrinet_alphabet:a {:RESULT = a; :} | {:RESULT = null; :} ;

internal_alphabet_opt ::= internal_alphabet:intern {:RESULT = intern; :} | {: RESULT = new IdentifierListAST(); :};

internal_alphabet ::= INTERNAL_ALPHABET EQ LBRACE:l identifier_list_opt:idList  RBRACE:r
					  {:idList.setLocation(getLocation(l$, r$));
						RESULT = idList; :};

return_alphabet_opt ::= return_alphabet:ret {:RESULT = ret; :} | {:RESULT = new IdentifierListAST(); :};

return_alphabet ::= RETURN_ALPHABET EQ LBRACE:l identifier_list_opt:idList RBRACE:r
					{:idList.setLocation(getLocation(l$, r$));
					  RESULT = idList; :} ;

states_opt ::= states:st {:RESULT = st; :} | {:RESULT = null; :} ;

states ::= STATES EQ LBRACE:l identifier_list_opt:idList RBRACE:r
		   {:idList.setLocation(getLocation(l$, r$));
			 RESULT = idList; :} ;

initial_states_opt ::= initial_states:init {:RESULT = init; :} | {:RESULT = new IdentifierListAST(); :};

initial_states ::= INITIAL_STATES EQ LBRACE:l identifier_list_opt:idList RBRACE:r
				   {:idList.setLocation(getLocation(l$, r$));
				     RESULT = idList; :} ;

final_states_opt ::= final_states:fin {:RESULT = fin; :} | {:RESULT = new IdentifierListAST(); :};

final_states ::= FINAL_STATES EQ LBRACE:l identifier_list_opt:idList RBRACE:r
				{:idList.setLocation(getLocation(l$, r$));
				  RESULT = idList; :} ;

call_transitions_opt ::= call_transitions:c {:RESULT = c; :} | {:RESULT = new TransitionListAST(); :};

call_transitions ::= CALL_TRANSITIONS EQ LBRACE:l transition_list_opt:tList RBRACE:r
					{: if (tList != null) {
						tList.setLocation(getLocation(l$, r$));
					}
						RESULT = tList; :};

internal_transitions_opt ::= internal_transitions:i {:RESULT = i; :} | {:RESULT = new TransitionListAST(); :} ;

internal_transitions ::= INTERNAL_TRANSITIONS EQ LBRACE:l transition_list_opt:tList RBRACE:r
						{:if (tList != null) {
							tList.setLocation(getLocation(l$, r$));
						}
						  RESULT = tList; :};

return_transitions_opt ::= return_transitions:ret {:RESULT = ret; :} | {:RESULT = new TransitionListAST(); :} ;

return_transitions ::= RETURN_TRANSITIONS EQ LBRACE:l transition_list_opt:tList RBRACE:r
						{: if (tList != null) {
							tList.setLocation(getLocation(l$, r$));
						}
						  RESULT = tList; :};
						  
transition_list_opt ::= transition_list:tList {: RESULT = tList; :} | {:RESULT = new TransitionListAST(); :} ;						  

transition_list ::= transition:idList 
					{:TransitionListAST tList = new TransitionListAST();
 						tList.addTransition(idList);
						RESULT = tList; :} 
                   | transition_list:tList transition:idList
                     {: tList.addTransition(idList);
                    	  RESULT = tList; :}
                   
                   ;

transition ::= LPAREN:l identifier_list_opt:idList RPAREN:r
               {: idList.setLocation(getLocation(l$, r$));
                 RESULT = idList; :} ;                 


petrinetJulian_definition ::= variable_identifier:id EQ LPAREN:l
                              alphabet_opt:alpha COMMA
                              places:p COMMA
                              net_transitions:net_trans COMMA
                              initial_markings:init_mark COMMA
                              accepting_places:acc_places RPAREN:r
                              {: PetriNetAutomatonAST petri = new PetriNetAutomatonAST(id);
                                 petri.setAlphabet(alpha.getIdentifierList());
                                 petri.setPlaces(p.getIdentifierList());
                                 petri.setTransitions(net_trans.getNetTransitions());
                                 petri.setInitialMarkings(init_mark);
                                 petri.setAcceptingPlaces(acc_places.getIdentifierList());
                                 petri.setLocation(getLocation(l$, r$));
                                 m_varDeclarations.put(id, PetriNetJulian.class);
                            	 RESULT = petri; :}
                              ;

petrinet_alphabet ::= ALPHABET EQ LBRACE:l identifier_list_opt:idList RBRACE:r
						{:if (idList == null) {
							RESULT = null;
						} else {
							idList.setLocation(getLocation(l$, r$));
							RESULT = idList;
						}:};

places ::= PLACES EQ LBRACE:l  identifier_list_opt:idList RBRACE:r
							{:idList.setLocation(getLocation(l$, r$));
							  RESULT = idList; :};

net_transitions ::= NET_TRANSITIONS EQ LBRACE net_transition_list_opt:net_trans RBRACE
                    {: RESULT = net_trans; :} ;

net_transition_list_opt ::= net_transition_list:trans {: RESULT = trans; :}  | {: RESULT = new TransitionListAST(); :} ;

net_transition_list ::= net_transition:net_trans 
			{: TransitionListAST tList = new TransitionListAST();
                          tList.addNetTransition(net_trans);
                          RESULT = tList; :} 
                      | net_transition_list:tList net_transition:net_trans
                        {: tList.addNetTransition(net_trans);
                        	RESULT = tList; :} 
                      ;


net_transition ::= LPAREN:l marking:m1 identifier:id marking:m2 RPAREN:r
                   {: PetriNetTransitionAST net_trans = new PetriNetTransitionAST(m1, id, m2);
                     net_trans.setLocation(getLocation(l$, r$));
                     RESULT = net_trans;
                      :} ; 

initial_markings ::= INITIAL_MARKINGS EQ marking:m {:RESULT = new PetriNetMarkingListAST(m); :}  ;

marking ::= LBRACE:l identifier_list:idList RBRACE:r
            {: idList.setLocation(getLocation(l$, r$));
              RESULT = idList; :} ;

accepting_places ::= ACCEPTING_PLACES EQ LBRACE:l identifier_list:idList RBRACE:r 
{: idList.setLocation(getLocation(l$, r$)); 
	RESULT = idList; :} ;


