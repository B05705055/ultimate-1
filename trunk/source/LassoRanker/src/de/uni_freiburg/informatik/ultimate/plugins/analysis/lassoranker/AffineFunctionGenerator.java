package de.uni_freiburg.informatik.ultimate.plugins.analysis.lassoranker;

import java.math.BigInteger;
import java.util.*;

import de.uni_freiburg.informatik.ultimate.logic.Rational;
import de.uni_freiburg.informatik.ultimate.logic.Script;
import de.uni_freiburg.informatik.ultimate.logic.Term;
import de.uni_freiburg.informatik.ultimate.logic.TermVariable;
import de.uni_freiburg.informatik.ultimate.model.boogie.BoogieVar;


/**
 * The AffineFunctionGenerator creates template instances of affine-linear
 * functions to be used in LinearInequality instances.
 * 
 * A valuation on the generated variables can be used to create an
 * AffineFunction instance.
 * 
 * @author Jan Leike
 */
public class AffineFunctionGenerator {
	private Term m_constant;
	private Map<BoogieVar, Term> m_coefficients;
	
	/**
	 * Name of the variable for the affine function's affine constant
	 */
	private static String constName(String prefix) {
		return prefix + "c";
	}
	
	/**
	 * Name of the variable for the affine function's coefficients
	 */
	private static String coeffName(String prefix, BoogieVar var) {
		return prefix + "_" + var.getGloballyUniqueId();
	}
	
	/**
	 * @param script current SMT script
	 * @param variables the set of variables that need coefficients
	 * @param prefix new variables' name prefix
	 */
	public AffineFunctionGenerator(Script script,
			Collection<BoogieVar> variables, String prefix) {
		// Create variables
		m_constant = AuxiliaryMethods.newConstant(script, constName(prefix),
				"Real");
		m_coefficients = new HashMap<BoogieVar, Term>();
		for (BoogieVar var : variables) {
			m_coefficients.put(var, AuxiliaryMethods.newConstant(script,
					coeffName(prefix, var), "Real"));
		}
	}
	
	/**
	 * Generate the linear inequality
	 * @param vars a mapping from Boogie variables to TermVariables to be used
	 * @return Linear inequality corresponding to si(x)
	 */
	public LinearInequality generate(Map<BoogieVar, TermVariable> vars) {
		LinearInequality li = new LinearInequality();
		li.add(new AffineTerm(m_constant, Rational.ONE));
		for (Map.Entry<BoogieVar, TermVariable> entry : vars.entrySet()) {
			if (m_coefficients.containsKey(entry.getKey())) {
				li.add(entry.getValue(),
						new AffineTerm(m_coefficients.get(entry.getKey()),
								Rational.ONE));
			}
		}
		return li;
	}
	
	/**
	 * Return all SMT variables used by this template
	 */
	public Collection<Term> getVariables() {
		Collection<Term> vars = new ArrayList<Term>();
		vars.addAll(m_coefficients.values());
		vars.add(m_constant);
		return vars;
	}
	
	/**
	 * Extract coefficients from the model and convert them to an AffineFunction
	 * @param val the assignment
	 * @return an instance of the affine function generated by this generator
	 */
	public AffineFunction extractAffineFunction(Map<Term, Rational> val) {
		AffineFunction f = new AffineFunction();
		
		// Compute the greatest common denominator
		Rational gcd = Rational.ONE.gcd(val.get(m_constant));
		for (Map.Entry<BoogieVar, Term> entry : m_coefficients.entrySet()) {
			gcd = gcd.gcd(val.get(entry.getValue()));
		}
		
		// Multiply all coefficients with the greatest common denominator
		f.setConstant(val.get(m_constant).div(gcd).numerator());
		for (Map.Entry<BoogieVar, Term> entry : m_coefficients.entrySet()) {
			Rational c = val.get(entry.getValue()).div(gcd);
			assert(c.denominator().equals(BigInteger.ONE));
			f.put(entry.getKey(), c.numerator());
		}
		
		return f;
	}
}