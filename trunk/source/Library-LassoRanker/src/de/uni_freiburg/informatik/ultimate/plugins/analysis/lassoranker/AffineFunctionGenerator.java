/*
 * Copyright (C) 2012-2014 University of Freiburg
 *
 * This file is part of the ULTIMATE LassoRanker Library.
 *
 * The ULTIMATE LassoRanker Library is free software: you can redistribute it
 * and/or modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * The ULTIMATE LassoRanker Library is distributed in the hope that it will
 * be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with the ULTIMATE LassoRanker Library. If not,
 * see <http://www.gnu.org/licenses/>.
 * 
 * Additional permission under GNU GPL version 3 section 7:
 * If you modify the ULTIMATE LassoRanker Library, or any covered work, by
 * linking or combining it with Eclipse RCP (or a modified version of
 * Eclipse RCP), containing parts covered by the terms of the Eclipse Public
 * License, the licensors of the ULTIMATE LassoRanker Library grant you
 * additional permission to convey the resulting work.
 */
package de.uni_freiburg.informatik.ultimate.plugins.analysis.lassoranker;

import java.io.Serializable;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.LinkedHashMap;
import java.util.Map;

import de.uni_freiburg.informatik.ultimate.logic.Rational;
import de.uni_freiburg.informatik.ultimate.logic.Script;
import de.uni_freiburg.informatik.ultimate.logic.Term;
import de.uni_freiburg.informatik.ultimate.modelcheckerutils.smt.SmtUtils;


/**
 * The AffineFunctionGenerator creates template instances of affine-linear
 * functions to be used in LinearInequality instances.
 * 
 * A valuation on the generated variables can be used to create an
 * AffineFunction instance.
 * 
 * @author Jan Leike
 */
public class AffineFunctionGenerator implements Serializable {
	private static final long serialVersionUID = 4376363192635730213L;
	
	private final Term m_constant;
	private final Map<RankVar, Term> m_coefficients;
	
	/**
	 * Name of the variable for the affine function's affine constant
	 */
	private static String constName(String prefix) {
		return prefix + "c";
	}
	
	/**
	 * Name of the variable for the affine function's coefficients
	 */
	private static String coeffName(String prefix, RankVar var) {
		return prefix + "_" + SmtUtils.removeSmtQuoteCharacters(
													var.getGloballyUniqueId());
	}
	
	/**
	 * @param script current SMT script
	 * @param variables the set of variables that need coefficients
	 * @param prefix new variables' name prefix
	 */
	public AffineFunctionGenerator(Script script, Collection<RankVar> variables,
			String prefix) {
		// Create variables
		m_constant = SMTSolver.newConstant(script, constName(prefix),
				"Real");
		m_coefficients = new LinkedHashMap<RankVar, Term>();
		for (RankVar var : variables) {
			m_coefficients.put(var, SMTSolver.newConstant(script,
					coeffName(prefix, var), "Real"));
		}
	}
	
	/**
	 * Generate the linear inequality
	 * @param vars a mapping from Boogie variables to TermVariables to be used
	 * @return Linear inequality corresponding to si(x)
	 */
	public LinearInequality generate(Map<RankVar, Term> vars) {
		LinearInequality li = new LinearInequality();
		li.add(new AffineTerm(m_constant, Rational.ONE));
		for (Map.Entry<RankVar, Term> entry : vars.entrySet()) {
			if (m_coefficients.containsKey(entry.getKey())) {
				li.add(entry.getValue(),
						new AffineTerm(m_coefficients.get(entry.getKey()),
								Rational.ONE));
			}
		}
		return li;
	}
	
	/**
	 * Return all SMT variables used by this template
	 */
	public Collection<Term> getVariables() {
		Collection<Term> vars = new ArrayList<Term>();
		vars.addAll(m_coefficients.values());
		vars.add(m_constant);
		return vars;
	}
	
	/**
	 * Extract coefficients from the model and convert them to an AffineFunction
	 * @param val the assignment
	 * @return an instance of the affine function generated by this generator
	 */
	public AffineFunction extractAffineFunction(Map<Term, Rational> val) {
		AffineFunction f = new AffineFunction();
		
		// Compute the greatest common denominator
		Rational gcd = Rational.ONE.gcd(val.get(m_constant));
		for (Map.Entry<RankVar, Term> entry : m_coefficients.entrySet()) {
			gcd = gcd.gcd(val.get(entry.getValue()));
		}
		
		// Multiply all coefficients with the greatest common denominator
		f.setConstant(val.get(m_constant).div(gcd).numerator());
		for (Map.Entry<RankVar, Term> entry : m_coefficients.entrySet()) {
			Rational c = val.get(entry.getValue()).div(gcd);
			assert(c.denominator().equals(BigInteger.ONE));
			f.put(entry.getKey(), c.numerator());
		}
		
		return f;
	}
}