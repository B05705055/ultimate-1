// Author: heizmann@informatik.uni-freiburg.de
// Date: 2.8.2011

print(beverageVendingMachine);
//print(alwaysDispenceSpecification);
//assert(buchiAccepts(beverageVendingMachine, [, select paidInsufficient]));
//assert(!buchiAccepts(alwaysDispenceSpecification, [, select paidInsufficient]));
//assert(buchiAccepts(buchiComplementFKV(alwaysDispenceSpecification), [, select paidInsufficient]));

assert(!buchiIsEmpty(buchiIntersect(beverageVendingMachine buchiComplementFKV(alwaysDispenceSpecification))));

NestedWordAutomaton beverageVendingMachine = (
  callAlphabet = {},
  internalAlphabet = { select paidSufficient paidInsufficient dispence },
  returnAlphabet = {},
  states = {idle checkPayment paymentChecked},
  initialStates = {idle},
  finalStates = {idle checkPayment paymentChecked},
  callTransitions = {},
  internalTransitions = {
    (idle select checkPayment) 
    (checkPayment paidSufficient paymentChecked)
    (checkPayment paidInsufficient idle)
    (paymentChecked dispence idle)
  }, 
  returnTransitions = {}
);


NestedWordAutomaton alwaysDispenceSpecification = (
  callAlphabet = {},
  internalAlphabet = { select paidSufficient paidInsufficient dispence },
  returnAlphabet = {},
  states = {notSelected selected},
  initialStates = {notSelected},
  finalStates = {notSelected},
  callTransitions = {},
  internalTransitions = {
    (notSelected paidSufficient notSelected) 
    (notSelected paidInsufficient notSelected) 
    (notSelected dispence notSelected) 
    (notSelected select selected)
    (selected select selected) 
    (selected paidSufficient selected) 
    (selected paidInsufficient selected) 
    (selected dispence notSelected) 
 }, 
  returnTransitions = {}
);
