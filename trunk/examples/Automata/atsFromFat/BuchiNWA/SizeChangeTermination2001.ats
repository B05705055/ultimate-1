// Example taken from Neils POPL2001 paper.
// The automaton callGraph represents the call graph of Example 3. The
// automaton infeasible represents the automaton of the figure in Section 3.
// infeasible accepts all call sequences (=traces) which are infeasible because
// they cause an infinite decent on a value.
//
// infeasible accepts all traces
// callGraph accpts all traces
// the language of callGraph intersected with the complement of infeasible is
// the empty set.

// Author: heizmann@informatik.uni-freiburg.de
// Date: 19.5.2011




assert(buchiAccepts(infeasibleN, [3 , 3 3]));
assert(!buchiAccepts(buchiComplementFKV(infeasibleN), [3 , 3 3]));


assert(buchiAccepts(infeasible, [1 3 3, 3 3]));
assert(buchiAccepts(infeasible, [1 , 3 3]));
assert(!buchiAccepts(buchiComplementFKV(infeasible), [1 , 3 3]));
assert(!buchiAccepts(buchiComplementFKV(infeasible), [1 3 3, 3 3]));
assert(buchiIsEmpty(buchiComplementFKV(infeasible)));

assert(buchiAccepts(infeasible, [1 1, 1 1]));
assert(!buchiAccepts(buchiComplementFKV(infeasible), [1 1, 1 1]));
assert(buchiIsEmpty(buchiComplementFKV(infeasible)));
assert(!buchiAccepts(buchiIntersect(callGraph, buchiComplementFKV(infeasible)), [1 1, 1 1]));
assert(buchiIsEmpty(buchiIntersect(callGraph, buchiComplementFKV(infeasible))));

//print(buchiComplementFKV(callGraph));
print(buchiComplementFKV(infeasibleN));


NestedWordAutomaton callGraph = (
  callAlphabet = { },
  internalAlphabet = { 1 2 3},
  returnAlphabet = { },
  states = {a},
  initialStates = {a},
  finalStates = {a},
  callTransitions = { },
  internalTransitions = { 
    (a 1 a) (a 2 a) (a 3 a)
  }, 
  returnTransitions = { }
);

NestedWordAutomaton infeasible = (
  callAlphabet = { },
  internalAlphabet = { 1 2 3},
  returnAlphabet = { },
  states = {init m mStrict n nStrict},
  initialStates = {init},
  finalStates = {mStrict nStrict},
  callTransitions = { },
  internalTransitions = { 
    (init 1 init) (init 2 init) (init 3 init) 
    (init 1 m) (init 2 m) (init 3 m) 
    (init 1 n) (init 2 n) (init 3 n) 
    (m 3 m)
    (m 1 mStrict) (m 2 mStrict)
    (mStrict 1 mStrict) (mStrict 2 mStrict)
    (mStrict 3 m)
    (n 3 nStrict)
    (nStrict 3 n)
  }, 
  returnTransitions = { }
);

NestedWordAutomaton infeasibleN = (
  callAlphabet = { },
  internalAlphabet = { 1 2 3},
  returnAlphabet = { },
  states = {init n nStrict},
  initialStates = {init},
  finalStates = {nStrict},
  callTransitions = { },
  internalTransitions = { 
    (init 1 init) (init 2 init) (init 3 init) 
    (init 1 n) (init 2 n) (init 3 n) 
    (n 3 nStrict)
    (nStrict 3 n)
  }, 
  returnTransitions = { }
);
