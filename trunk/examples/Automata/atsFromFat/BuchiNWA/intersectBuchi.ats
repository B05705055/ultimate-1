// Examples for testing correctness of buchiIntersect operation

// Author: heizmann@informatik.uni-freiburg.de
// Date: 15.5.2011




assert(buchiAccepts(nonNestedBuchi1, [a , a ]));
assert(buchiAccepts(nonNestedBuchi2, [a , a ]));
assert(buchiAccepts(buchiIntersect(nonNestedBuchi1 nonNestedBuchi2), [a , a ]));
assert(!buchiIsEmpty(buchiIntersect(nonNestedBuchi1 nonNestedBuchi2)));

assert(buchiAccepts(cKistner, [, c<  c<  a >r >r ]));
assert(buchiAccepts(cKistnerSelfLoopFree, [, c<  c<  a >r >r ]));
assert(!buchiIsEmpty(buchiIntersect(cKistner cKistnerSelfLoopFree)));

assert(buchiAccepts(finitelyManyA, [ a a b a, b ]));
assert(!buchiIsEmpty(finitelyManyA));

assert(!buchiAccepts(finitelyManyB, [ a a a a a a , b ]));
assert(!buchiIsEmpty(finitelyManyB));
assert(buchiIsEmpty(buchiIntersect(finitelyManyA finitelyManyB)));


assert(buchiAccepts(infinitelyManyA, [ , a b b b ]));
assert(!buchiAccepts(infinitelyManyA, [ , b ]));
assert(!buchiAccepts(buchiIntersect(infinitelyManyA infinitelyManyB), [ , b]));
assert(buchiAccepts(buchiIntersect(infinitelyManyA infinitelyManyB), [ , a b]));


print(buchiIntersect(infinitelyManyA infinitelyManyB));


NestedWordAutomaton nonNestedBuchi1 = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {s0 s1},
  initialStates = {s0},
  finalStates = {s0},
  callTransitions = { },
  internalTransitions = {(s0 a s1) (s1 a s0)}, 
  returnTransitions = { }
);

NestedWordAutomaton nonNestedBuchi2 = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {s0 s1 s2},
  initialStates = {s0},
  finalStates = {s1},
  callTransitions = { },
  internalTransitions = {(s0 a s1) (s1 a s2) (s2 a s0)}, 
  returnTransitions = { }
);

NestedWordAutomaton cKistner = (
  callAlphabet = { c },
  internalAlphabet = {a b},
  returnAlphabet = { r },
  states = {s0 s1 s2},
  initialStates = {s0},
  finalStates = {s1},
  callTransitions = { (s0 c s0) },
  internalTransitions = {(s0 a s1) }, 
  returnTransitions = { (s1 s0 r s2) (s2 s0 r s0) }
);

NestedWordAutomaton cKistnerSelfLoopFree = (
  callAlphabet = { c },
  internalAlphabet = {a b},
  returnAlphabet = { r },
  states = {s0 r0 r1 s1 s2},
  initialStates = {s0},
  finalStates = {s1},
  callTransitions = { (s0 c r0) (r0 c r1)  },
  internalTransitions = {(r1 a s1) }, 
  returnTransitions = { (s1 r0 r s2) (s2 s0 r s0) }
);


NestedWordAutomaton finitelyManyA = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {q0 q1},
  initialStates = {q0},
  finalStates = {q1},
  callTransitions = { },
  internalTransitions = { (q0 a q0) (q0 b q0) (q0 b q1) (q1 b q1) }, 
  returnTransitions = { }
);

NestedWordAutomaton finitelyManyB = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {q0 q1},
  initialStates = {q0},
  finalStates = {q1},
  callTransitions = { },
  internalTransitions = { (q0 b q0) (q0 a q0) (q0 a q1) (q1 a q1) }, 
  returnTransitions = { }
);




NestedWordAutomaton infinitelyManyA = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {q0 q1},
  initialStates = {q0},
  finalStates = {q1},
  callTransitions = { },
  internalTransitions = { (q0 a q1) (q0 b q0) (q1 a q1) (q1 b q0) }, 
  returnTransitions = { }
);

NestedWordAutomaton infinitelyManyB = (
  callAlphabet = { },
  internalAlphabet = {a b},
  returnAlphabet = { },
  states = {q0 q1},
  initialStates = {q0},
  finalStates = {q1},
  callTransitions = { },
  internalTransitions = { (q0 b q1) (q0 a q0) (q1 b q1) (q1 a q0) }, 
  returnTransitions = { }
);
